## Table of Contents
|排序方法|平均时间复杂度|最坏时间复杂度|最好时间复杂度|空间复杂度|稳定性|
|:-|:-:|:-:|:-:|:-:|:-:|
|[Insertion Sort \| 插入排序](#Insertion-Sort--插入排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Hill Sort \| 希尔排序](#Hill-Sort--希尔排序)|O(N^1.3)|O(N^2)|O(N)|O(1)|No|
|[Selection Sort \| 选择排序](#Selection-Sort--选择排序)|O(N^2)|O(N^2)|O(N^2)|O(1)|No|
|[Heap Sort \| 堆排序⭐️](#Heap-Sort--堆排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(1)|No|
|[Bubble Sort \| 冒泡排序](#Bubble-Sort--冒泡排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Quick Sort \| 快速排序⭐️](#Quick-Sort--快速排序)|O(NlogN)|O(N^2)|O(NlogN)|O(NlogN)|No|
|[Merge Sort \| 归并排序⭐️](#Merge-Sort--归并排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(N)|Yes|

---
|排序方法|平均时间复杂度|最坏时间复杂度|最好时间复杂度|空间复杂度|稳定性|
|:-|:-:|:-:|:-:|:-:|:-:|
|计数排序|O(N+k)|O(N+k)|O(N+k)|O(N+K)|Yes|
|桶排序|O(N+k)|O(N^2)|O(N)|O(N+k)|Yes|
|基数排序|O(N*k)|O(N*k)|O(N*k)|O(N+k)|Yes|

---
|序号|题目|难度|
|:-:|:-|:-:|
|75|[Sort Colors \| 颜色分类](#75-Sort-Colors--颜色分类)|Medium|

### Insertion Sort | 插入排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 1; i != nums.size(); ++i) {
            //🪁对新插入的数据从后向前遍历比较便于位置交换
            for (int j = i - 1; j >= 0 && nums[j + 1] < nums[j]; --j) {
                //🪁使用内层j下标进行相邻元素的比较可以避免对i的误改
                swap(nums[j + 1], nums[j]);
            }
        }
        return nums;
    }
};
```

### Hill Sort | 希尔排序

### Selection Sort | 选择排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 0; i != nums.size() - 1; ++i) {
            //🪁循环过程中每遇到小于起始位置的元素就交换一次,确定最小值放在最前
            for (int j = i + 1; j != nums.size(); ++j) {
                if (nums[i] > nums[j]) swap(nums[i], nums[j]);
            }
        }
        return nums;
    }
};
```

### Heap Sort | 堆排序
```c++
class Solution {
public:
    vector<int> heapSort(vector<int> &nums) {
        priority_queue<int, vector<int>, greater<int>> temp;
        vector<int> result;
        for (int num : nums) temp.push(num);
        while (!temp.empty()) {
            result.push_back(temp.top());
            temp.pop();
        }
        return result;
    }
}
```

### Bubble Sort | 冒泡排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int times = nums.size() - 1; //总共进行N-1次循环
        while (times--) {
            for (int i = 0; i != nums.size() - 1; ++i) {
                //🪁循环过程中每遇到相邻逆序对就交换一次,确定最大值放在最后
                if (nums[i] > nums[i + 1]) swap(nums[i], nums[i + 1]);
            }
        } //🪁总的交换次数与数组的逆序数相等
        return nums;
    }
};
```

### Quick Sort | 快速排序
```c++
class Solution {
public:
    void quickSort(vector<int> &nums, int begin, int end) {
        //退出条件：只剩一个或没有元素的时候
        if (end <= begin) return;
        int pivot = partition(nums, begin, end); //定位pivot
        //递归
        quickSort(nums, begin, pivot - 1);
        quickSort(nums, pivot + 1, end);
    }

    int partition(vector<int> &nums, int &begin, int &end) {
        //pivot：标杆位置；counter：不小于pivot元素的初始位置
        int pivot = end, counter = begin;
        for (int i = begin; i != end; ++i) {
            if (nums[i] < nums[pivot]) {
                int temp = nums[counter];
                nums[counter++] = nums[i];
                nums[i] = temp;
            }
        }
        int temp = nums[counter];
        nums[counter] = nums[end];
        nums[end] = temp;
        return counter; 
    }
}
```

### Merge Sort | 归并排序
时间复杂度: `O(NlogN)`  空间复杂度: `O(N)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }
    
    void mergeSort(vector<int> &nums, int left, int right) {
        if (left >= right) return; //终止条件
        int mid = (left + right) >> 1;
        //🪁分治(递归),合并子序列
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        mergeSubsequence(nums, left, mid, right);
    }
    
    void mergeSubsequence(vector<int> &nums, int left, int mid, int right) {
        vector<int> temp;
        int i = left, j = mid + 1;
        while (i <= mid && j <= right) {
            nums[i] < nums[j] ? temp.push_back(nums[i++]) : temp.push_back(nums[j++]);
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int i = 0; i != temp.size(); ++i) nums[left + i] = temp[i];
    }
};
```

### 计数排序
### 桶排序
时间复杂度: `O(N+K)`  空间复杂度: `O(K)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int max_val = nums[0], min_val = nums[0];
        for (int i = 1; i != nums.size(); ++i) {
            max_val = max(max_val, nums[i]);
            min_val = min(min_val, nums[i]);
        }
        //🪁结合数组的下标填入对应数字出现的次数
        vector<int> occur(max_val - min_val + 1);
        for (int i = 0; i != nums.size(); ++i) {
            occur[nums[i] - min_val]++;
        }
        //遍历输出对应次数的元素
        int i = 0;
        for (int j = 0; j != max_val - min_val + 1; ++j) {
            while (occur[j]--) nums[i++] = j + min_val; 
        }
        return nums;
    }
};
```
### 基数排序



### 75. Sort Colors | 颜色分类
🥈给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
```
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2]
```
---

标签: `排序`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int curr = 0, less = 0, more = nums.size() - 1;
        //🪁小的数往前排,大的数往后排
        while (curr <= more) {
            switch (nums[curr]) {
                case 0: swap(nums[curr++], nums[less++]); break;
                case 1: curr++; break;
                case 2: swap(nums[curr], nums[more--]); break;
            }
        }
    }
};
```
