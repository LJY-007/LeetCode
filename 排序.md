## Table of Contents
|排序方法|平均时间复杂度|最坏时间复杂度|最好时间复杂度|空间复杂度|稳定性|
|:-|:-:|:-:|:-:|:-:|:-:|
|[Insertion Sort \| 插入排序](#Insertion-Sort--插入排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Hill Sort \| 希尔排序](#Hill-Sort--希尔排序)|O(N^1.3)|O(N^2)|O(N)|O(1)|No|
|[Selection Sort \| 选择排序](#Selection-Sort--选择排序)|O(N^2)|O(N^2)|O(N^2)|O(1)|No|
|[Heap Sort \| 堆排序⭐️](#Heap-Sort--堆排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(1)|No|
|[Bubble Sort \| 冒泡排序](#Bubble-Sort--冒泡排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Quick Sort \| 快速排序⭐️](#Quick-Sort--快速排序)|O(NlogN)|O(N^2)|O(NlogN)|O(NlogN)|No|
|[Merge Sort \| 归并排序⭐️](#Merge-Sort--归并排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(N)|Yes|
---
|排序方法|平均时间复杂度|最坏时间复杂度|最好时间复杂度|空间复杂度|稳定性|
|:-|:-:|:-:|:-:|:-:|:-:|
|计数排序|O(N+k)|O(N+k)|O(N+k)|O(N+K)|Yes|
|桶排序|O(N+k)|O(N^2)|O(N)|O(N+k)|Yes|
|基数排序|O(N*k)|O(N*k)|O(N*k)|O(N+k)|Yes|


### Insertion Sort | 插入排序
### Hill Sort | 希尔排序
### Selection Sort | 选择排序

### Heap Sort | 堆排序
```c++
class Solution {
public:
    vector<int> heapSort(vector<int> &nums) {
        priority_queue<int, vector<int>, greater<int>> temp;
        vector<int> result;
        for (int num : nums) temp.push(num);
        while (!temp.empty()) {
            result.push_back(temp.top());
            temp.pop();
        }
        return result;
    }
}
```

### Bubble Sort | 冒泡排序

### Quick Sort | 快速排序
```c++
class Solution {
public:
    void quickSort(vector<int> &nums, int begin, int end) {
        //退出条件：只剩一个或没有元素的时候
        if (end <= begin) return;
        int pivot = partition(nums, begin, end); //定位pivot
        //递归
        quickSort(nums, begin, pivot - 1);
        quickSort(nums, pivot + 1, end);
    }

    int partition(vector<int> &nums, int &begin, int &end) {
        //pivot：标杆位置；counter：不小于pivot元素的初始位置
        int pivot = end, counter = begin;
        for (int i = begin; i != end; ++i) {
            if (nums[i] < nums[pivot]) {
                int temp = nums[counter];
                nums[counter++] = nums[i];
                nums[i] = temp;
            }
        }
        int temp = nums[counter];
        nums[counter] = nums[end];
        nums[end] = temp;
        return counter; 
    }
}
```

### Merge Sort | 归并排序
```c++
class Solution {
public:
    void mergeSort(vector<int> &nums, int left, int right) {
        if (left >= right) return;
        int mid = (left + right) >> 1;
        //递归
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        mergeSubsequence(nums, left, mid, right); //合并子序列
    }

    void mergeSubsequence(vector<int> &nums, int &left, int &mid, int &right) {
        vector<int> temp;
        int i = left, j = mid + 1;
        while (i <= mid && j <= right) {
            nums[i] < nums[j] ? temp.push_back(nums[i++]) : temp.push_back(nums[j++]);
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int i = 0; i != temp.size(); ++i) {
            nums[left + i] = temp[i];
        }
    }
}
```

### 计数排序
### 桶排序
### 基数排序
