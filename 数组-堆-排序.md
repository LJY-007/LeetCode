## Table of Contents
|序号|题目|难度|
|:--:|:-|:-:|
|75|[Sort Colors \| 颜色分类](#75-Sort-Colors--颜色分类)|Medium|
|295|[Find Median from Data Stream \| 数据流中的中位数](#295-Find-Median-from-Data-Stream--数据流中的中位数)|Hard|
|912|[Sort an Array \| 排序数组](#912-Sort-an-Array--排序数组)|Medium|



### 75. Sort Colors | 颜色分类
🥈给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
```
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2]
```
---

标签: `排序`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int curr = 0, less = 0, more = nums.size() - 1;
        //🪁小的数往前排,大的数往后排
        while (curr <= more) {
            switch (nums[curr]) {
                case 0: swap(nums[curr++], nums[less++]); break;
                case 1: curr++; break;
                case 2: swap(nums[curr], nums[more--]); break;
            }
        }
    }
};
```

### 295. Find Median from Data Stream | 数据流中的中位数
🏅️如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>
设计一个支持以下两种操作的数据结构：
```
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
```

标签: `堆` `动态排序`<br>
时间复杂度:`O(logN)` 空间复杂度:`O(N)`
```c++
class MedianFinder {
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (less.empty()) {
            less.push(num);
            return;
        }
        //🪁将新数据压入堆中(与大根堆的根元素比较),同时确保大根堆上元素个数等于或大于小根堆上元素个数一个
        num <= less.top() ?  less.push(num) : great.push(num);
        if (less.size() > great.size() + 1) {
            great.push(less.top());
            less.pop();
        } else if (less.size() < great.size()) {
            less.push(great.top());
            great.pop();
        }
    }
    
    double findMedian() {
        return less.size() == great.size() ? (less.top() + great.top()) / 2.0 : less.top();
    }
    
private:
    //🪁利用一个大根堆(存较小的数)和一个小根堆(存较大的数)来存储数据
    priority_queue<int, vector<int>, less<int>> less;
    priority_queue<int, vector<int>, greater<int>> great;
};
```

### 912. Sort an Array | 排序数组
🥈给你一个整数数组 nums，请你将该数组升序排列。
```
输入：nums = [5,2,3,1] 输出：[1,2,3,5]
输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5]
```
---

#### Kinds of Sorts
|排序方法|平均时间复杂度|最坏时间复杂度|最好时间复杂度|空间复杂度|稳定性|
|:-|:-:|:-:|:-:|:-:|:-:|
|[Insertion Sort \| 插入排序](#Insertion-Sort--插入排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Hill Sort \| 希尔排序](#Hill-Sort--希尔排序)|O(N^1.3)|O(N^2)|O(N)|O(1)|No|
|[Selection Sort \| 选择排序](#Selection-Sort--选择排序)|O(N^2)|O(N^2)|O(N^2)|O(1)|No|
|[Heap Sort \| 堆排序⭐️](#Heap-Sort--堆排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(1)|No|
|[Bubble Sort \| 冒泡排序](#Bubble-Sort--冒泡排序)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Quick Sort \| 快速排序⭐️](#Quick-Sort--快速排序)|O(NlogN)|O(N^2)|O(NlogN)|O(logN)|No|
|[Merge Sort \| 归并排序⭐️](#Merge-Sort--归并排序)|O(NlogN)|O(NlogN)|O(NlogN)|O(N)|Yes|
|计数排序|O(N+k)|O(N+k)|O(N+k)|O(N+K)|Yes|
|桶排序|O(N+k)|O(N^2)|O(N)|O(N+k)|Yes|
|基数排序|O(N*k)|O(N*k)|O(N*k)|O(N+k)|Yes|

#### Insertion Sort | 插入排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 1; i != nums.size(); ++i) {
            //🪁对新插入的数据从后向前遍历比较便于位置交换
            for (int j = i - 1; j >= 0 && nums[j + 1] < nums[j]; --j) {
                //🪁使用内层j下标进行相邻元素的比较可以避免对i的误改
                swap(nums[j + 1], nums[j]);
            }
        }
        return nums;
    }
};
```

#### Hill Sort | 希尔排序

#### Selection Sort | 选择排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 0; i != nums.size() - 1; ++i) {
            //🪁循环过程中每遇到小于起始位置的元素就交换一次,确定最小值放在最前
            for (int j = i + 1; j != nums.size(); ++j) {
                if (nums[i] > nums[j]) swap(nums[i], nums[j]);
            }
        }
        return nums;
    }
};
```

#### Heap Sort | 堆排序
```c++
class Solution {
public:
    vector<int> heapSort(vector<int> &nums) {
        priority_queue<int, vector<int>, greater<int>> temp;
        vector<int> result;
        for (int num : nums) temp.push(num);
        while (!temp.empty()) {
            result.push_back(temp.top());
            temp.pop();
        }
        return result;
    }
}
```

##### Bubble Sort | 冒泡排序
时间复杂度: `O(N^2)`  空间复杂度: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int times = nums.size() - 1; //总共进行N-1次循环
        while (times--) {
            for (int i = 0; i != nums.size() - 1; ++i) {
                //🪁循环过程中每遇到相邻逆序对就交换一次,确定最大值放在最后
                if (nums[i] > nums[i + 1]) swap(nums[i], nums[i + 1]);
            }
        } //🪁总的交换次数与数组的逆序数相等
        return nums;
    }
};
```

#### Quick Sort | 快速排序
时间复杂度: `O(NlogN)`  空间复杂度: `O(logN)`
```c++
class Solution {
public:
    void quickSort(vector<int> &nums, int begin, int end) {
        if (end <= begin) return;
        int pivot = partition(nums, begin, end);
        quickSort(nums, begin, pivot - 1); //🪁pivot可能等于begin或end,退出时end会小于begin
        quickSort(nums, pivot + 1, end);
    }

    int partition(vector<int> &nums, int begin, int end) {
        //🪁pivot：标杆位置；less：所有小于pivot元素的下一位置
        int pivot = end, less = begin;
        srand(time(NULL)); //设置一个随机种子
        int p_rand = int(rand() % 100 / 100.0 * (end - begin + 1)) + begin; //生成随机位置
        swap(nums[pivot], nums[p_rand]);
        for (int i = begin; i != end; ++i) {
            if (nums[i] < nums[pivot]) swap(nums[i], nums[less++]);
        }
        swap(nums[less], nums[end]);
        return less; 
    }
};
```

#### Merge Sort | 归并排序
时间复杂度: `O(NlogN)`  空间复杂度: `O(N)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }
    
    void mergeSort(vector<int> &nums, int left, int right) {
        if (left >= right) return; //终止条件
        int mid = (left + right) >> 1;
        //🪁分治(递归),合并子序列
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        mergeSubsequence(nums, left, mid, right);
    }
    
    void mergeSubsequence(vector<int> &nums, int left, int mid, int right) {
        vector<int> temp;
        int i = left, j = mid + 1;
        while (i <= mid && j <= right) {
            nums[i] < nums[j] ? temp.push_back(nums[i++]) : temp.push_back(nums[j++]);
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int i = 0; i != temp.size(); ++i) nums[left + i] = temp[i];
    }
};
```

#### 计数排序

#### 桶排序
时间复杂度: `O(N+K)`  空间复杂度: `O(K)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int max_val = nums[0], min_val = nums[0];
        for (int i = 1; i != nums.size(); ++i) {
            max_val = max(max_val, nums[i]);
            min_val = min(min_val, nums[i]);
        }
        //🪁结合数组的下标填入对应数字出现的次数
        vector<int> occur(max_val - min_val + 1);
        for (int i = 0; i != nums.size(); ++i) {
            occur[nums[i] - min_val]++;
        }
        //遍历输出对应次数的元素
        int i = 0;
        for (int j = 0; j != max_val - min_val + 1; ++j) {
            while (occur[j]--) nums[i++] = j + min_val; 
        }
        return nums;
    }
};
```
#### 基数排序
