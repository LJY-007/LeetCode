## Table of Contents
|序号|题目|难度|
|:--:|:-|:-:|
|2|[Add Two Numbers \| 两数相加](#2-Add-Two-Numbers--两数相加)|Medium|
|19|[Remove Nth Node From End of List \| 删除链表的倒数第N个节点](#19-Remove-Nth-Node-From-End-of-List--删除链表的倒数第N个节点)|Medium|
|21|[Merge Two Sorted Lists \| 合并两个有序链表](#21-Merge-Two-Sorted-Lists--合并两个有序链表)|Easy|
|23|[Merge k Sorted Lists \| 合并K个排序链表](#23-Merge-k-Sorted-Lists--合并K个排序链表)|Hard|
|24|[Swap Nodes in Pairs \| 两两交换链表中的节点](#24-Swap-Nodes-in-Pairs--两两交换链表中的节点)|Medium|
|25|[Reverse Nodes in k-Group \| K 个一组翻转链表](#25-Reverse-Nodes-in-k-Group--K-个一组翻转链表)|Hard|
|61|[Rotate List \| 旋转链表](#61-Rotate-List--旋转链表)|Medium|
|82|[Remove Duplicates from Sorted List II \| 删除排序链表中的重复元素 II](#82-Remove-Duplicates-from-Sorted-List-II--删除排序链表中的重复元素-II)|Medium|
|83|[Remove Duplicates from Sorted List \| 删除排序链表中的重复元素](#83-Remove-Duplicates-from-Sorted-List--删除排序链表中的重复元素)|Easy|
|86|[Partition List \| 分隔链表](#86-Partition-List--分隔链表)|Medium|
|92|[Reverse Linked List II \| 反转链表 II](#92-Reverse-Linked-List-II--反转链表-II)|Medium|
|138|[Copy List with Random Pointer \| 复制带随机指针的链表](#138-Copy-List-with-Random-Pointer--复制带随机指针的链表)|Medium|
|141|[Linked List Cycle \| 环形链表](#141-Linked-List-Cycle--环形链表)|Easy|
|142|||
|143|||
||||
||||
||||
|206|[Reverse Linked List \| 反转链表](#206-Reverse-Linked-List--反转链表)|Easy|

### 2. Add Two Numbers | 两数相加
🥈给出两个**非空**的链表用来表示两个非负的整数。其中，它们各自的位数是按**逆序**的方式存储的，并且它们的每个节点只能存储**一位**数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
---

```c++
to be filled
```

### 19. Remove Nth Node From End of List | 删除链表的倒数第N个节点
🥈给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
```
给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
---

```c++
to be filled
```

### 21. Merge Two Sorted Lists | 合并两个有序链表
🥉将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
```
输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4
```
---

```c++
to be filled
```

### 23. Merge k Sorted Lists | 合并K个排序链表
🏅️合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```
---

```c++
to be filled
```

### 24. Swap Nodes in Pairs | 两两交换链表中的节点
🥈给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```
给定 1->2->3->4, 返回 2->1->4->3.
```
---

```c++
to be filled
```

### 25. Reverse Nodes in k-Group | K 个一组翻转链表
🏅️给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
```
给你这个链表：1->2->3->4->5
当 k = 2 时，返回: 2->1->4->3->5
当 k = 3 时，返回: 3->2->1->4->5
说明：
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```
---

```c++
to be filled
```

### 61. Rotate List | 旋转链表
🥈给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
```
输入: 1->2->3->4->5->NULL, k = 2 输出: 4->5->1->2->3->NULL
解释: 向右旋转 1 步: 5->1->2->3->4->NULL 向右旋转 2 步: 4->5->1->2->3->NULL
```
---

```c++
to be filled
```

### 82. Remove Duplicates from Sorted List II | 删除排序链表中的重复元素 II
🥈给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中**没有重复出现**的数字。
```
输入: 1->2->3->3->4->4->5
输出: 1->2->5
```
---

```c++
to be filled
```

### 83. Remove Duplicates from Sorted List | 删除排序链表中的重复元素
🥉给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
```
输入: 1->1->2 输出: 1->2
```
---

```c++
to be filled
```

### 86. Partition List | 分隔链表
🥈给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。
```
输入: head = 1->4->3->2->5->2, x = 3 输出: 1->2->2->4->3->5
```
---

```c++
to be filled
```

### 92. Reverse Linked List II | 反转链表 II
🥈反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明: 1 ≤ m ≤ n ≤ 链表长度。
```
输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL
```
---

```c++
to be filled
```

### 138. Copy List with Random Pointer | 复制带随机指针的链表
🥈给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
要求返回这个链表的**深拷贝**。 
我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。
```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]]
输入：head = [] 输出：[]
```
---

```c++
to be filled
```

### 141. Linked List Cycle | 环形链表
🥉给定一个链表，判断链表中是否有环。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
```
输入：head = [3,2,0,-4], pos = 1 输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
输入：head = [1], pos = -1 输出：false
```
---

```c++
to be filled
```

### 206. Reverse Linked List | 反转链表
🥉反转一个单链表。
```
输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL
```
---

```c++
to be filled
```

