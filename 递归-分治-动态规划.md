## Table of Contents
|序号|题目|难度|
|-|-|-|
|63|[Unique Paths II \| 不同路径 II](#63-Unique-Paths-II--不同路径-II)|Medium|
|509|[Fibonacci Number \| 斐波那契数](#509-Fibonacci-Number--斐波那契数)|Medium|
|1143|[Longest Common Subsequence \| 最长公共子序列](#1143-Longest-Common-Subsequence--最长公共子序列)|Medium|

### Nots
动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）
```
KEYS：
最优子结构：opt[n] = best of(opt[n-1], opt[n-2]...)
存储中间状态：opt[n]
递推公式（DP方程，状态转移方程）: 
例如 Fib(opt[i] = opt[n-1]+opt[n-2]); 二维路径(opt[i,j]=opt[i+1][j]+opt[i][j+1])(且判断a[i][j]是否为空)
```

### 63. Unique Paths II | 不同路径 II
🥈一个机器人位于一个 m x n 网格的左上角，试图达到网格的右下角且每次只能向下或者向右移动一步。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。
```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
] 
输出: 2
解释: 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右
```
---

标签: `DP`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;
        obstacleGrid[0][0] = 1; //起点的可达路径应设置为1

        int r = obstacleGrid.size(), c = obstacleGrid[0].size();
        //🪁每个点位的可达路径由上方和左方的点位对应的可达路径得出
        for (int i = 0; i != r; ++i) {
            //第一列每一点位（每一行的第一个点位）的路径值由其上方的点位决定
            if (i) {
                obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
            }
            for (int j = 1; j != c; ++j) {
                //第一行的每一个点位的路径值由其左方的点位决定
                if (i == 0) {
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1];
                } else {
                    //🪁递推方程为opt[i][j]=opt[i][j-1]+opt[i-1][j]，如果opt[i][j]=1，则需要归零
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j];
                }
            }
        }
        return obstacleGrid[r - 1][c - 1];
    }
};
```



### 509. Fibonacci Number | 斐波那契数
🥈斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。给定 N，计算 F(N)。
```
输入：4 输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
```
---

标签: `递归法`<br>
时间复杂度:`O(2^N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        return (N <= 1) ? N : fib(N - 1) + fib(N - 2);
    }
};
```

标签: `递归法` `记忆化搜索`<br>
时间复杂度:`O(N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        vector<int> memo(N + 1); //初始化vector为N+1个0
        return fibStored(N, memo);
    }

    //🪁记忆化搜索利用数组来存储已经计算过的值避免重复调用计算
    int fibStored(int N, vector<int> &memo) {
        if (N <= 1) return N;
        //当fib(N)尚未计算时，执行递归计算
        if (memo[N] == 0) {
            memo[N] = fibStored(N - 1, memo) + fibStored(N - 2, memo);
        }
        return memo[N];
    }
};
```

标签: `DP自底向上`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int pre = 0, post = 1;
        for (int i = 2; i <= N; ++i) {
            post += pre;
            pre = post - pre; //结合减法避免了临时变量的申请
        }
        return post;
    }
};
```

### 1143. Longest Common Subsequence | 最长公共子序列
🥈给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
```
输入：text1 = "abcde", text2 = "ace" 输出：3 解释：最长公共子序列是 "ace"，它的长度为 3。
输入：text1 = "abc", text2 = "def" 输出：0
```
---

标签: `DP` `二维数组`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(M*N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //dp[i][j]表示在字符串text1[0...r-1]中和字符串text2[0...c-1]中最长公共子序列的长度为dp[i][j]。
        vector<vector<int>> dp(r + 1, vector<int> (c + 1));
        for (int i = 1; i != r + 1; ++i) {
            for (int j = 1; j != c + 1; ++j) { 
                if (text1[i - 1] == text2[j - 1]) {
                    //🪁dp[i][j]位置对应两字符串的最后一个字符相同时，dp[i][j]取决于dp[i-1][j-1]加一
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    //🪁否则应取dp[i-1][j]，dp[i][j-1]中的较大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        } 
        return dp[r][c];
    }
};
```

标签: `DP` `一维数组`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //🪁用一维数组可以来存储状态可以节省空间
        vector<int> dp(c + 1);
        for (int i = 0; i != r; ++i) {
            vector<int> temp(c + 1);
            for (int j = 1; j != c + 1; ++j) {
                temp[j] = (text1[i] == text2[j - 1]) ? dp[j - 1] + 1 : max(temp[j - 1], dp[j]);
            }
            dp = temp;
        }
        return dp[c];
    }
};
```
