## Table of Contents
|åºå·|é¢˜ç›®|éš¾åº¦|
|:-:|:-|:-:|
|4|||
|39|||
|46|||
|51|||
|53|[Maximum Subarray \| æœ€å¤§å­åºå’Œ](#53-Maximum-Subarray--æœ€å¤§å­åºå’Œ)|Easy|
|62|[Unique Paths \| ä¸åŒè·¯å¾„](#62-Unique-Paths--ä¸åŒè·¯å¾„)|Medium|
|63|[Unique Paths II \| ä¸åŒè·¯å¾„ II](#63-Unique-Paths-II--ä¸åŒè·¯å¾„-II)|Medium|
|64|[Minimum Path Sum \| æœ€å°è·¯å¾„å’Œ](#64-Minimum-Path-Sum--æœ€å°è·¯å¾„å’Œ)|Medium|
|70|[Climbing Stairs \| çˆ¬æ¥¼æ¢¯](#70-Climbing-Stairs--çˆ¬æ¥¼æ¢¯)|Easy|
|72|||
|91|||
|120|[Triangle \| ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ](#120-Triangle--ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ)|Medium|
|121|[Best Time to Buy and Sell Stock \| ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](#121-Best-Time-to-Buy-and-Sell-Stock--ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº)|Easy|
|122|||
|123|||
|152|[Maximum Product Subarray \| ä¹˜ç§¯æœ€å¤§å­æ•°ç»„](#152-Maximum-Product-Subarray-ä¹˜ç§¯æœ€å¤§å­æ•°ç»„)|Medium|
|174|[Dungeon Game \| åœ°ä¸‹åŸæ¸¸æˆ](#174-Dungeon-Game--åœ°ä¸‹åŸæ¸¸æˆ)|Hard|
|198|[House Robber \| æ‰“å®¶åŠ«èˆ](#198-House-Robber--æ‰“å®¶åŠ«èˆ)|Easy|
|213|[House Robber II \| æ‰“å®¶åŠ«èˆ II](#213-House-Robber-II--æ‰“å®¶åŠ«èˆ-II)|Medium|
|241|||
|279|||
|300|[Longest Increasing Subsequence \| æœ€é•¿ä¸Šå‡å­åºåˆ—](#300-Longest-Increasing-Subsequence--æœ€é•¿ä¸Šå‡å­åºåˆ—)|Medium|
|322|[Coin Change \| é›¶é’±å…‘æ¢](#322-Coin-Change--é›¶é’±å…‘æ¢)|Medium|
|337|[House Robber III \| æ‰“å®¶åŠ«èˆ III](#337-House-Robber-III--æ‰“å®¶åŠ«èˆ-III)|Medium|
|343|[Integer Break \| æ•´æ•°æ‹†åˆ†](#343-Integer-Break--æ•´æ•°æ‹†åˆ†)|Medium|
|509|[Fibonacci Number \| æ–æ³¢é‚£å¥‘æ•°](#509-Fibonacci-Number--æ–æ³¢é‚£å¥‘æ•°)|Medium|
|1143|[Longest Common Subsequence \| æœ€é•¿å…¬å…±å­åºåˆ—](#1143-Longest-Common-Subsequence--æœ€é•¿å…¬å…±å­åºåˆ—)|Medium|

### Nots
åŠ¨æ€è§„åˆ’å’Œé€’å½’æˆ–è€…åˆ†æ²»æ²¡æœ‰æ ¹æœ¬ä¸Šçš„åŒºåˆ«ï¼ˆå…³é”®çœ‹æœ‰æ— æœ€ä¼˜çš„å­ç»“æ„ï¼‰
```
KEYSï¼š
æœ€ä¼˜å­ç»“æ„ï¼šopt[n] = best of(opt[n-1], opt[n-2]...)
å­˜å‚¨ä¸­é—´çŠ¶æ€ï¼šopt[n]
é€’æ¨å…¬å¼ï¼ˆDPæ–¹ç¨‹ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼‰: 
ä¾‹å¦‚ Fib(opt[i] = opt[n-1]+opt[n-2]); äºŒç»´è·¯å¾„(opt[i,j]=opt[i+1][j]+opt[i][j+1])(ä¸”åˆ¤æ–­a[i][j]æ˜¯å¦ä¸ºç©º)
```
`ä¸»å®šç†`
T(N) = a\*T(N/b) + O(N^d)
```
log(b,a) > d å¤æ‚åº¦ä¸ºO(N^log(b,a))
log(b,a) = d å¤æ‚åº¦ä¸ºO(N^d * logN)
log(b,a) < d å¤æ‚åº¦ä¸ºO(N^d)
```

### 53. Maximum Subarray | æœ€å¤§å­åºå’Œ
ğŸ¥‰ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
```
è¾“å…¥: [-2,1,-3,4,-1,2,1,-5,4] è¾“å‡º: 6
è§£é‡Š: è¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ã€‚
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.empty()) return -1;
        //ğŸªä»¥ç¬¬iä½ç½®ä¸ºç»“å°¾çš„æœ€å¤§è¿ç»­å­åºå’Œ:dp[i]=nums[i]+max(0,dp[i-1])
        int curr = nums[0], res = curr;
        for (int i = 1; i != nums.size(); ++i) {
            curr = nums[i] + max(0, curr);
            res = max(curr, res);
        }
        return res;
    }
};
```

### 62. Unique Paths | ä¸åŒè·¯å¾„
ğŸ¥ˆä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ã€‚æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ã€‚é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
```
è¾“å…¥: m = 3, n = 2 è¾“å‡º: 3
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        //ğŸªåˆ°è¾¾ç¬¬iè¡Œjåˆ—ä½ç½®çš„ä¸åŒè·¯å¾„æ•°:dp[i][j]=dp[i-1][j]+dp[i][j-1]
        vector<int> row(n,1);
        while (--m) {
            for (int i = 1; i!= n; ++i) {
                row[i] += row[i - 1];  
            }
        }
        return row[n - 1];
    }
};
```

### 63. Unique Paths II | ä¸åŒè·¯å¾„ II
ğŸ¥ˆä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ï¼Œè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ä¸”æ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ 1 å’Œ 0 æ¥è¡¨ç¤ºã€‚
```
è¾“å…¥:
[
Â  [0,0,0],
Â  [0,1,0],
Â  [0,0,0]
] 
è¾“å‡º: 2
è§£é‡Š: ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ä¸€å…±æœ‰ 2 æ¡ä¸åŒçš„è·¯å¾„ï¼š1. å‘å³ -> å‘å³ -> å‘ä¸‹ -> å‘ä¸‹ 2. å‘ä¸‹ -> å‘ä¸‹ -> å‘å³ -> å‘å³
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;
        //ğŸªåˆ°è¾¾ç¬¬iè¡Œjåˆ—ä½ç½®çš„ä¸åŒè·¯å¾„æ•°:bp[i][j]=bp[i][j-1]+bp[i-1][j],å¦‚æœobstacleGrid[i][j]=1,åˆ™å½’é›¶
        obstacleGrid[0][0] = 1; //èµ·ç‚¹çš„å¯è¾¾è·¯å¾„åº”è®¾ç½®ä¸º1
        int r = obstacleGrid.size(), c = obstacleGrid[0].size();
        for (int i = 0; i != r; ++i) {
            //ç¬¬ä¸€åˆ—æ¯ä¸€ç‚¹ä½ï¼ˆæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªç‚¹ä½ï¼‰çš„è·¯å¾„å€¼ç”±å…¶ä¸Šæ–¹çš„ç‚¹ä½å†³å®š
            if (i) {
                obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
            }
            for (int j = 1; j != c; ++j) {
                //ç¬¬ä¸€è¡Œçš„æ¯ä¸€ä¸ªç‚¹ä½çš„è·¯å¾„å€¼ç”±å…¶å·¦æ–¹çš„ç‚¹ä½å†³å®š
                if (i == 0) {
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1];
                } else {
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j];
                }
            }
        }
        return obstacleGrid[r - 1][c - 1];
    }
};
```
### 64. Minimum Path Sum | æœ€å°è·¯å¾„å’Œ
ğŸ¥ˆç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ m x n ç½‘æ ¼ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚æ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚
```
è¾“å…¥:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
è¾“å‡º: 7
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (grid.empty()) return 0;
        //ğŸªåˆ°è¾¾ç¬¬iè¡Œjåˆ—ä½ç½®çš„æœ€å°è·¯å¾„å’Œ:dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j]
        vector<int> row(grid[0].size());
        for (int i = 0; i != grid.size(); ++i) {
            row[0] = (i == 0) ? grid[0][0] : row[0] + grid[i][0]; 
            for (int j = 1; j != grid[0].size(); ++j) {
                row[j] = (i == 0) ? grid[0][j] + row[j - 1] : min(row[j], row[j - 1]) + grid[i][j];
            }
        }
        return row[grid[0].size() - 1];
    }
};
```

### 70. Climbing Stairs | çˆ¬æ¥¼æ¢¯
ğŸ¥‰å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿæ³¨æ„ï¼šç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚
```
è¾“å…¥ï¼š2 è¾“å‡ºï¼š2
è§£é‡Šï¼šæœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚1. 1 é˜¶ + 1 é˜¶ 2. 2 é˜¶
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int climbStairs(int n) {
        int pre = 1, post = 2;
        //ğŸªåˆ°è¾¾ç¬¬ié˜¶å°é˜¶çš„æ–¹æ³•:dp[i]=dp[i-1]+dp[i-2]
        for (int i = 3; i <= n; ++i) {
            post = pre + post;
            pre = post - pre;
        }
        return n <= 2 ? n : post;
    }
};
```

### 120. Triangle | ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ
ğŸ¥ˆç»™å®šä¸€ä¸ªä¸‰è§’å½¢ï¼Œæ‰¾å‡ºè‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚æ¯ä¸€æ­¥åªèƒ½ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œä¸­ç›¸é‚»çš„ç»“ç‚¹ä¸Šã€‚
```
è¾“å…¥ï¼š
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
è¾“å‡ºï¼š11ï¼ˆå³ 2 + 3 + 5 + 1 = 11ï¼‰
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N^2)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        //ğŸªåˆ°è¾¾ç¬¬iè¡Œjåˆ—ä½ç½®çš„æœ€å°è·¯å¾„å’Œ:dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle[i][j]
        for (int i = triangle.size() - 2; i >= 0; --i) {
            for (int j = 0; j != triangle[i].size(); ++j) {
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
            }
        }
        return triangle[0][0];
    }
};
```

### 121. Best Time to Buy and Sell Stock | ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
ğŸ¥‰ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚å¦‚æœä½ æœ€å¤šåªå…è®¸å®Œæˆä¸€ç¬”äº¤æ˜“ï¼ˆå³ä¹°å…¥å’Œå–å‡ºä¸€æ”¯è‚¡ç¥¨ä¸€æ¬¡ï¼‰ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚æ³¨æ„ï¼šä½ ä¸èƒ½åœ¨ä¹°å…¥è‚¡ç¥¨å‰å–å‡ºè‚¡ç¥¨ã€‚
```
è¾“å…¥: [7,1,5,3,6,4] è¾“å‡º: 5
è¾“å…¥: [7,6,4,3,1] è¾“å‡º: 0
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) return 0;
        //ğŸªåœ¨ç¬¬iå¤©å–å‡ºçš„æœ€å¤§åˆ©æ¶¦(è¿ç»­å­åºå’Œ):dp[i]=max(0,dp[i-1])+prices[i]-prices[i-1]
        int curr = prices[1] - prices[0], res = max(0, curr);
        for (int i = 2; i != prices.size(); ++i) {
            curr = max(0, curr) + prices[i] - prices[i - 1];
            res = max(res, curr);
        }
        return res;
    }
};
```

æ ‡ç­¾: `å•è°ƒæ ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) return 0;
        //ğŸªä½¿ç”¨å•è°ƒæ ˆä¸­æ ˆé¡¶ä¸æ ˆåº•å…ƒç´ ä»£è¡¨çš„è‚¡ç¥¨å·®ä»·æ¥ç¡®å®šèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦
        stack<int> stocks;
        int bottom = 0, res = 0;
        for (int i = 0; i != prices.size(); ++i) {
            while (!stocks.empty() && stocks.top() > prices[i]) stocks.pop();
            stocks.push(prices[i]);
            if (stocks.size() == 1) bottom = stocks.top();
            res = max(res, stocks.top() - bottom);
        }
        return res;
    }
};
```

### 152. Maximum Product Subarray | ä¹˜ç§¯æœ€å¤§å­æ•°ç»„
ğŸ¥ˆç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­ä¹˜ç§¯æœ€å¤§çš„è¿ç»­å­æ•°ç»„ï¼ˆè¯¥å­æ•°ç»„ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰ï¼Œå¹¶è¿”å›è¯¥å­æ•°ç»„æ‰€å¯¹åº”çš„ä¹˜ç§¯ã€‚
```
è¾“å…¥: [2,3,-2,4] è¾“å‡º: 6
è§£é‡Š: å­æ•°ç»„ [2,3] æœ‰æœ€å¤§ä¹˜ç§¯ 6ã€‚
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if (nums.empty()) return -1;
        /*ğŸªä»¥ç¬¬iä¸ªä½ç½®ä¸ºç»“å°¾çš„ä¹˜ç§¯æœ€å¤§(å°)è¿ç»­å­æ•°ç»„:
            dp_max[i]=max(dp_max[i-1],1)*nums[i]),dp_min[i]=min(dp_min[i-1],1)*nums[i])*/
        int max_product = nums[0], min_product = nums[0];
        int res = nums[0];
        for (int i = 1; i != nums.size(); ++i) {
            int pre_max = max_product, pre_min = min_product;
            max_product = max(pre_max, 1) * nums[i];
            min_product = min(pre_min, 1) * nums[i];
            //ğŸªnums[i]<0æ—¶ä¸>=0æ—¶,ä¹˜ç§¯æœ€å¤§(å°)ç»“æœæƒ³å
            if (nums[i] < 0) swap(max_product, min_product);
            res = max(res, max_product);
        }
        return res;
    }
};
```

### 174. Dungeon Game | åœ°ä¸‹åŸæ¸¸æˆ
ğŸ…ï¸ä¸€äº›æ¶é­”æŠ“ä½äº†å…¬ä¸»ï¼ˆPï¼‰å¹¶å°†å¥¹å…³åœ¨äº†åœ°ä¸‹åŸçš„å³ä¸‹è§’ã€‚åœ°ä¸‹åŸæ˜¯ç”± M x N ä¸ªæˆ¿é—´ç»„æˆçš„äºŒç»´ç½‘æ ¼ã€‚æˆ‘ä»¬è‹±å‹‡çš„éª‘å£«ï¼ˆKï¼‰æœ€åˆè¢«å®‰ç½®åœ¨å·¦ä¸Šè§’çš„æˆ¿é—´é‡Œï¼Œä»–å¿…é¡»ç©¿è¿‡åœ°ä¸‹åŸå¹¶é€šè¿‡å¯¹æŠ—æ¶é­”æ¥æ‹¯æ•‘å…¬ä¸»ã€‚éª‘å£«çš„åˆå§‹å¥åº·ç‚¹æ•°ä¸ºä¸€ä¸ªæ­£æ•´æ•°ã€‚å¦‚æœä»–çš„å¥åº·ç‚¹æ•°åœ¨æŸä¸€æ—¶åˆ»é™è‡³ 0 æˆ–ä»¥ä¸‹ï¼Œä»–ä¼šç«‹å³æ­»äº¡ã€‚æœ‰äº›æˆ¿é—´ç”±æ¶é­”å®ˆå«ï¼Œå› æ­¤éª‘å£«åœ¨è¿›å…¥è¿™äº›æˆ¿é—´æ—¶ä¼šå¤±å»å¥åº·ç‚¹æ•°ï¼ˆè‹¥æˆ¿é—´é‡Œçš„å€¼ä¸ºè´Ÿæ•´æ•°ï¼Œåˆ™è¡¨ç¤ºéª‘å£«å°†æŸå¤±å¥åº·ç‚¹æ•°ï¼‰ï¼›å…¶ä»–æˆ¿é—´è¦ä¹ˆæ˜¯ç©ºçš„ï¼ˆæˆ¿é—´é‡Œçš„å€¼ä¸º 0ï¼‰ï¼Œè¦ä¹ˆåŒ…å«å¢åŠ éª‘å£«å¥åº·ç‚¹æ•°çš„é­”æ³•çƒï¼ˆè‹¥æˆ¿é—´é‡Œçš„å€¼ä¸ºæ­£æ•´æ•°ï¼Œåˆ™è¡¨ç¤ºéª‘å£«å°†å¢åŠ å¥åº·ç‚¹æ•°ï¼‰ã€‚ä¸ºäº†å°½å¿«åˆ°è¾¾å…¬ä¸»ï¼Œéª‘å£«å†³å®šæ¯æ¬¡åªå‘å³æˆ–å‘ä¸‹ç§»åŠ¨ä¸€æ­¥ã€‚<br>
ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—ç¡®ä¿éª‘å£«èƒ½å¤Ÿæ‹¯æ•‘åˆ°å…¬ä¸»æ‰€éœ€çš„æœ€ä½åˆå§‹å¥åº·ç‚¹æ•°ã€‚
```
è€ƒè™‘åˆ°å¦‚ä¸‹å¸ƒå±€çš„åœ°ä¸‹åŸï¼Œå¦‚æœéª‘å£«éµå¾ªæœ€ä½³è·¯å¾„ å³ -> å³ -> ä¸‹ -> ä¸‹ï¼Œåˆ™éª‘å£«çš„åˆå§‹å¥åº·ç‚¹æ•°è‡³å°‘ä¸º 7ã€‚
[
  [-2(K),-3,3],
  [-5,-10,1],
  [10,30,-5(P)]
]
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        if (dungeon.empty()) return 1;
        int m = dungeon.size(), n = dungeon[0].size();
        vector<int> dp(n);
        //ğŸªä»ç¬¬iè¡Œjåˆ—ä½ç½®åˆ°å³ä¸‹è§’ä½ç½®çš„æœ€ä½åˆå§‹ç‚¹æ•°:dp[i][j]=max(1, min(dp[i+1][j],dp[i][j+1])-dungeon[i][j])        
        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);
        for (int i = m - 1; i >= 0; --i) {
            if (i != m - 1) dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]);
            for (int j = n - 2; j >= 0; --j) {
                if (i == m - 1) {
                    dp[j] = max(1, dp[j + 1] - dungeon[i][j]);
                } else {
                    dp[j]= max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);
                }
            }
        }
        return dp[0];  
    }
};
```


### 198. House Robber | æ‰“å®¶åŠ«èˆ
ğŸ¥‰ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½ åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ï¼Œèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
```
è¾“å…¥: [1,2,3,1] è¾“å‡º: 4
è§£é‡Š: å·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 1) ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 3)ã€‚å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        if (nums.size() == 1) return nums[0];
        //ğŸªåˆ°ç¬¬iä¸ªæˆ¿é—´æ—¶èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢:dp[i]=max(dp[i-2]+nums[i],dp[i-1])
        int pre = nums[0], post = max(pre, nums[1]);
        for (int i = 2; i != nums.size(); ++i) {
            int temp = post;
            post = max(pre + nums[i], post);
            pre = temp;
        }
        return post;
    }
};
```

### 213. House Robber II | æ‰“å®¶åŠ«èˆ II
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½å›´æˆä¸€åœˆï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½ åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ï¼Œèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
```
è¾“å…¥: [2,3,2] è¾“å‡º: 3
è§£é‡Š: ä½ ä¸èƒ½å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰, ç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰, å› ä¸ºä»–ä»¬æ˜¯ç›¸é‚»çš„.
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        if (nums.size() == 1) return nums[0];
        //ğŸªåˆ°ç¬¬iä¸ªæˆ¿é—´æ—¶èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢:dp[i]=max(dp[i-2]+nums[i],dp[i-1])
        int pre1 = nums[0], post1 = max(pre1, nums[1]);
        if (nums.size() == 2) return post1;
        int pre2 = nums[1], post2 = max(pre2, nums[2]);
        //ğŸªå¯ç†è§£ä¸ºæ±‚ä¸¤ç§å·çªƒèŒƒå›´ä¸­(ä»ç¬¬ä¸€ä¸ªæˆ¿é—´åˆ°å€’æ•°ç¬¬äºŒä¸ªæˆ¿é—´æˆ–ä»ç¬¬äºŒä¸ªæˆ¿é—´åˆ°æœ€åä¸€ä¸ªæˆ¿é—´)å¯å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢
        for (int i = 2; i != nums.size() - 1; ++i) {
            int temp1 = post1, temp2 = post2;
            post1 = max(pre1 + nums[i], post1);
            pre1 = temp1;
            post2 = max(pre2 + nums[i + 1], post2);
            pre2 = temp2;
        }
        return max(post1, post2);
    }
};
```

### 300. Longest Increasing Subsequence | æœ€é•¿ä¸Šå‡å­åºåˆ—
ğŸ¥ˆç»™å®šä¸€ä¸ªæ— åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚
```
è¾“å…¥: [10,9,2,5,3,7,101,18] è¾“å‡º: 4 
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N^2)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;
        //ğŸªä»¥ç¬¬iä¸ªå…ƒç´ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦:dp[i]=max(dp[j]),for(j<i&&nums[j]<nums[i])
        vector<int> dp(nums.size(),1);
        int res = 1;
        for (int i = 1; i != nums.size(); ++i) {
            for (int j = 0; j != i; ++j) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                }
            }
            res = max(dp[i], res);
        }
        return res;
    }
};
```

æ ‡ç­¾: `æ ˆ`<br>
æ—¶é—´å¤æ‚åº¦:`O(N^2)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;
        //ğŸªä½¿ç”¨æ ˆç»“æ„æŒ‰é¡ºåºå‹å…¥,æ ˆçš„é¡¶ç«¯å§‹ç»ˆä¸ºæœ€é•¿ä¸Šå‡å­åºåˆ—çš„æœ€å¤§å€¼
        vector<int> stack; //ä½¿ç”¨vectorå®ç°stackç»“æ„ä¾¿äºéå†
        stack.push_back(nums[0]);
        for (int i = 1; i != nums.size(); ++i) {
            //ğŸªå½“å¾…å‹å…¥å…ƒç´ å°äºç­‰äºæ˜¯æ ˆé¡¶å…ƒç´ æ—¶,å°†å…¶è¦†ç›–æ ˆä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºçš„å…ƒç´ 
            if (nums[i] <= stack.back()) {
                for (int j = 0; j != stack.size(); ++j) {
                    if (stack[j] >= nums[i]) {
                        stack[j] = nums[i];
                        break;
                    }
                } 
            } else { 
                stack.push_back(nums[i]);
            }
        }
        return stack.size();
    }
};
```


### 322. Coin Change | é›¶é’±å…‘æ¢
ğŸ¥ˆç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸ coins å’Œä¸€ä¸ªæ€»é‡‘é¢ amountã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1ã€‚
```
è¾“å…¥: coins = [1, 2, 5], amount = 11 è¾“å‡º: 3 
è§£é‡Š: 11 = 5 + 5 + 1
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(M)`
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, -1);
        dp[0] = 0;
        //ğŸªé‡‘é¢içš„æœ€å°ä½¿ç”¨ç¡¬å¸æ•°:dp[i]=min(dp[i-k])+1
        for (int i = 1; i != dp.size(); ++i) {
            for (auto coin : coins) {
                if (i >= coin && dp[i - coin] != -1) {
                    if (dp[i] == -1 || dp[i] > dp[i - coin] + 1) {
                        dp[i] = dp[i - coin] + 1;
                    }
                }
            }
        }
        return dp[amount];
    }
};
```

### 337. House Robber III | æ‰“å®¶åŠ«èˆ III
ğŸ¥ˆåœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚
```
è¾“å…¥: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1
è¾“å‡º: 7 
è§£é‡Š:Â å°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ = 3 + 3 + 1 = 7.
```
---

æ ‡ç­¾: `é€’å½’æ³•` `è®°å¿†åŒ–æœç´¢`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int rob(TreeNode* root) {
        if (!root) return 0;
        //ğŸªå­˜å‚¨è®°å¿†è®¡ç®—è¿‡çš„ç»“ç‚¹å’Œä»è¯¥ç»“ç‚¹å¼€å§‹å¯å·çªƒçš„æœ€å¤§é‡‘é¢
        if (memo.count(root)) return memo[root];
        //ğŸªä»ç»“ç‚¹iå¼€å§‹å¯å·çªƒåˆ°çš„æœ€å¤§é‡‘é¢=max(ä»å„¿å­ç»“ç‚¹å¼€å§‹å¯å·çªƒçš„æœ€å¤§é‡‘é¢,ä»å­™å­ç»“ç‚¹å¼€å§‹å¯å·çªƒçš„æœ€å¤§é‡‘é¢+i->val)
        int money = root->val;
        if (root->left) money += rob(root->left->left) + rob(root->left->right);
        if (root->right) money += rob(root->right->left) + rob(root->right->right);
        memo[root] = max(money, rob(root->left) + rob(root->right));
        return memo[root];
    }
private:
    unordered_map<TreeNode*, int> memo;
};
```

æ ‡ç­¾: `é€’å½’æ³•`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(logN)`
```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> res = robChoose(root);
        return max(res[0], res[1]);
    }

    //ğŸªç»“ç‚¹iå¼€å§‹èƒ½å·åˆ°çš„æœ€å¤§é‡‘é¢(æ­¤ç»“ç‚¹å·/ä¸å·)=(i->val/0)+å·¦å³ç»“ç‚¹å¼€å§‹èƒ½å·åˆ°çš„æœ€å¤§é‡‘é¢(æ­¤ç»“ç‚¹ä¸å·/å¯å·)ä¹‹å’Œ
    vector<int> robChoose(TreeNode* root) {
        if (!root) return {0, 0};
        vector<int> left = robChoose(root->left), right = robChoose(root->right);
        int rob_yes = root->val + left[1] + right[1];
        int rob_no = max(left[0], left[1]) +  max(right[0], right[1]);
        return {rob_yes, rob_no};
    }
};
```

### 343. Integer Break | æ•´æ•°æ‹†åˆ†
ğŸ¥ˆç»™å®šä¸€ä¸ªæ­£æ•´æ•° nï¼Œå°†å…¶æ‹†åˆ†ä¸ºè‡³å°‘ä¸¤ä¸ªæ­£æ•´æ•°çš„å’Œï¼Œå¹¶ä½¿è¿™äº›æ•´æ•°çš„ä¹˜ç§¯æœ€å¤§åŒ–ã€‚ è¿”å›ä½ å¯ä»¥è·å¾—çš„æœ€å¤§ä¹˜ç§¯ã€‚
```
è¾“å…¥: 2 è¾“å‡º: 1
è¾“å…¥: 10 è¾“å‡º: 36 è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36.
```
---

æ ‡ç­¾: `DP`<br>
æ—¶é—´å¤æ‚åº¦:`O(N^2)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 1) return -1;
        //ğŸªå’Œä¸ºiçš„æ‹†åˆ†é¡¹çš„æœ€å¤§ä¹˜ç§¯:dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)))
        vector<int> dp(n + 1, 1);
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i/2; ++j) {
                dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)));
            }
        }
        return dp[n];
    }
};
```

### 509. Fibonacci Number | æ–æ³¢é‚£å¥‘æ•°
ğŸ¥ˆæ–æ³¢é‚£å¥‘æ•°ï¼Œé€šå¸¸ç”¨ F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ç»™å®š Nï¼Œè®¡ç®— F(N)ã€‚
```
è¾“å…¥: 4 è¾“å‡º: 3
è§£é‡Š: F(4) = F(3) + F(2) = 2 + 1 = 3.
```
---

æ ‡ç­¾: `é€’å½’æ³•`<br>
æ—¶é—´å¤æ‚åº¦:`O(2^N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        return (N <= 1) ? N : fib(N - 1) + fib(N - 2);
    }
};
```

æ ‡ç­¾: `é€’å½’æ³•` `è®°å¿†åŒ–æœç´¢`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        vector<int> memo(N + 1); //åˆå§‹åŒ–vectorä¸ºN+1ä¸ª0
        return fibStored(N, memo);
    }

    //ğŸªè®°å¿†åŒ–æœç´¢åˆ©ç”¨æ•°ç»„memo[i]æ¥å­˜å‚¨å·²ç»è®¡ç®—è¿‡çš„fib[i]å€¼,é¿å…é‡å¤è°ƒç”¨è®¡ç®—
    int fibStored(int N, vector<int> &memo) {
        if (N <= 1) return N;
        if (memo[N] == 0) {
            memo[N] = fibStored(N - 1, memo) + fibStored(N - 2, memo);
        }
        return memo[N];
    }
};
```

æ ‡ç­¾: `DPè‡ªåº•å‘ä¸Š`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int pre = 0, post = 1;
        for (int i = 2; i <= N; ++i) {
            post += pre;
            pre = post - pre; //ç»“åˆå‡æ³•é¿å…äº†ä¸´æ—¶å˜é‡çš„ç”³è¯·
        }
        return post;
    }
};
```

### 1143. Longest Common Subsequence | æœ€é•¿å…¬å…±å­åºåˆ—
ğŸ¥ˆç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² text1 å’Œ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ã€‚
ä¸€ä¸ªå­—ç¬¦ä¸²çš„Â å­åºåˆ—Â æ˜¯æŒ‡è¿™æ ·ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šå®ƒæ˜¯ç”±åŸå­—ç¬¦ä¸²åœ¨ä¸æ”¹å˜å­—ç¬¦çš„ç›¸å¯¹é¡ºåºçš„æƒ…å†µä¸‹åˆ é™¤æŸäº›å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰åç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚
ä¾‹å¦‚ï¼Œ"ace" æ˜¯ "abcde" çš„å­åºåˆ—ï¼Œä½† "aec" ä¸æ˜¯ "abcde" çš„å­åºåˆ—ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ã€Œå…¬å…±å­åºåˆ—ã€æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€å…±åŒæ‹¥æœ‰çš„å­åºåˆ—ã€‚
è‹¥è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰å…¬å…±å­åºåˆ—ï¼Œåˆ™è¿”å› 0ã€‚
```
è¾“å…¥ï¼štext1 = "abcde", text2 = "ace" è¾“å‡ºï¼š3 è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ "ace"ï¼Œå®ƒçš„é•¿åº¦ä¸º 3ã€‚
è¾“å…¥ï¼štext1 = "abc", text2 = "def" è¾“å‡ºï¼š0
```
---

æ ‡ç­¾: `DP` `äºŒç»´æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(M*N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //dp[i][j]è¡¨ç¤ºåœ¨å­—ç¬¦ä¸²text1[0...r-1]ä¸­å’Œå­—ç¬¦ä¸²text2[0...c-1]ä¸­æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ä¸ºdp[i][j]ã€‚
        vector<vector<int>> dp(r + 1, vector<int> (c + 1));
        for (int i = 1; i != r + 1; ++i) {
            for (int j = 1; j != c + 1; ++j) { 
                if (text1[i - 1] == text2[j - 1]) {
                    //ğŸªdp[i][j]ä½ç½®å¯¹åº”ä¸¤å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå­—ç¬¦ç›¸åŒæ—¶ï¼Œdp[i][j]å–å†³äºdp[i-1][j-1]åŠ ä¸€
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    //ğŸªå¦åˆ™åº”å–dp[i-1][j]ï¼Œdp[i][j-1]ä¸­çš„è¾ƒå¤§å€¼
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        } 
        return dp[r][c];
    }
};
```

æ ‡ç­¾: `DP` `ä¸€ç»´æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(M*N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //ğŸªç”¨ä¸€ç»´æ•°ç»„å¯ä»¥æ¥å­˜å‚¨çŠ¶æ€å¯ä»¥èŠ‚çœç©ºé—´
        vector<int> dp(c + 1);
        for (int i = 0; i != r; ++i) {
            vector<int> temp(c + 1);
            for (int j = 1; j != c + 1; ++j) {
                temp[j] = (text1[i] == text2[j - 1]) ? dp[j - 1] + 1 : max(temp[j - 1], dp[j]);
            }
            dp = temp;
        }
        return dp[c];
    }
};
```
