## Table of Contents
|序号|题目|难度|
|:-:|:-|:-:|
|53|[Maximum Subarray \| 最大子序和](#53-Maximum-Subarray--最大子序和)|Easy|
|63|[Unique Paths II \| 不同路径 II](#63-Unique-Paths-II--不同路径-II)|Medium|
|70|[Climbing Stairs \| 爬楼梯](#70-Climbing-Stairs--爬楼梯)|Easy|
|120|[Triangle \| 三角形最小路径和](#120-Triangle--三角形最小路径和)|Medium|
|152|[Maximum Product Subarray \| 乘积最大子数组](#152-Maximum-Product-Subarray-乘积最大子数组)|Medium|
|198|[House Robber \| 打家劫舍](#198-House-Robber--打家劫舍)|Easy|
|322|[Coin Change \| 零钱兑换](#322-Coin-Change--零钱兑换)|Medium|
|509|[Fibonacci Number \| 斐波那契数](#509-Fibonacci-Number--斐波那契数)|Medium|
|1143|[Longest Common Subsequence \| 最长公共子序列](#1143-Longest-Common-Subsequence--最长公共子序列)|Medium|

### Nots
动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）
```
KEYS：
最优子结构：opt[n] = best of(opt[n-1], opt[n-2]...)
存储中间状态：opt[n]
递推公式（DP方程，状态转移方程）: 
例如 Fib(opt[i] = opt[n-1]+opt[n-2]); 二维路径(opt[i,j]=opt[i+1][j]+opt[i][j+1])(且判断a[i][j]是否为空)
```
`主定理`
```
log(b,a) > d 复杂度为O(N^log(b,a))
log(b,a) = d 复杂度为O(N^d * logN)
log(b,a) < d 复杂度为O(N^d)
```

### 53. Maximum Subarray | 最大子序和
🥉给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```
输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大。
```
---

标签: `DP`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
       int res = nums[0];
       for (int i = 1; i != nums.size(); ++i) {
           //🪁nums[i]代表以[i]位置为结尾的最大连续子序和
           nums[i] += max(0, nums[i - 1]); //DP公式
           res = max(nums[i], res);
       }
       return res;
    }
};
```

### 63. Unique Paths II | 不同路径 II
🥈一个机器人位于一个 m x n 网格的左上角，试图达到网格的右下角且每次只能向下或者向右移动一步。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。
```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
] 
输出: 2
解释: 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右
```
---

标签: `DP`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;
        obstacleGrid[0][0] = 1; //起点的可达路径应设置为1

        int r = obstacleGrid.size(), c = obstacleGrid[0].size();
        //🪁每个点位的可达路径由上方和左方的点位对应的可达路径得出
        for (int i = 0; i != r; ++i) {
            //第一列每一点位（每一行的第一个点位）的路径值由其上方的点位决定
            if (i) {
                obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
            }
            for (int j = 1; j != c; ++j) {
                //第一行的每一个点位的路径值由其左方的点位决定
                if (i == 0) {
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1];
                } else {
                    //🪁递推方程为opt[i][j]=opt[i][j-1]+opt[i-1][j]，如果opt[i][j]=1，则需要归零
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j];
                }
            }
        }
        return obstacleGrid[r - 1][c - 1];
    }
};
```

### 70. Climbing Stairs | 爬楼梯
🥉假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。
```
输入：2 输出：2
解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶 2. 2 阶
```
---

```c++
class Solution {
public:
    int climbStairs(int n) {
        int pre = 1, post = 2;
        //🪁与fibonacci类似，f(n)=f(n-1)+f(n-2)
        for (int i = 3; i <= n; ++i) {
            post = pre + post;
            pre = post - pre;
        }
        return n <= 2 ? n : post;
    }
};
```

### 120. Triangle | 三角形最小路径和
🥈给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
```
输入：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
输出：11（即 2 + 3 + 5 + 1 = 11）
```
---

标签: `DP`<br>
时间复杂度:`O(N^2)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        for (int i = triangle.size() - 2; i >= 0; --i) {
            for (int j = 0; j != triangle[i].size(); ++j) {
                //🪁递推方程：dp[i][j]+=min(dp[i+1][j],dp[i+1][j+1])
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
            }
        }
        return triangle[0][0];
    }
};
```

### 152. Maximum Product Subarray | 乘积最大子数组
🥈给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```
输入: [2,3,-2,4] 输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```
---

```c++

```

### 198. House Robber | 打家劫舍
🥉你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
```
输入: [1,2,3,1] 输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。
```
---


### 322. Coin Change | 零钱兑换
🥈给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
```
输入: coins = [1, 2, 5], amount = 11 输出: 3 
解释: 11 = 5 + 5 + 1
```
---

标签: `DP`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(M)`
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //用amount+1(只要大于amount都可以)来初始化所有数组元素便于后续的取最小值的比较
        int limit = amount + 1;
        vector<int> dp(amount + 1, limit);
        dp[0] = 0;
        //🪁与爬楼梯问题异曲同工,只是台阶的阶数可选范围增大
        for (int i = 1; i <= amount; ++i) {
            for (auto coin : coins) {
                if (i >= coin) {
                    //🪁DP方程:f(n)=min(f(n-k))+1,k的取值为可取的硬币值
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        //如果dp数组的值仍然是limit则代表不可到达
        return (dp[amount] == limit) ? -1 : dp[amount];  
    }
};
```

### 509. Fibonacci Number | 斐波那契数
🥈斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。给定 N，计算 F(N)。
```
输入：4 输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
```
---

标签: `递归法`<br>
时间复杂度:`O(2^N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        return (N <= 1) ? N : fib(N - 1) + fib(N - 2);
    }
};
```

标签: `递归法` `记忆化搜索`<br>
时间复杂度:`O(N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        vector<int> memo(N + 1); //初始化vector为N+1个0
        return fibStored(N, memo);
    }

    //🪁记忆化搜索利用数组来存储已经计算过的值避免重复调用计算
    int fibStored(int N, vector<int> &memo) {
        if (N <= 1) return N;
        //当fib(N)尚未计算时，执行递归计算
        if (memo[N] == 0) {
            memo[N] = fibStored(N - 1, memo) + fibStored(N - 2, memo);
        }
        return memo[N];
    }
};
```

标签: `DP自底向上`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int pre = 0, post = 1;
        for (int i = 2; i <= N; ++i) {
            post += pre;
            pre = post - pre; //结合减法避免了临时变量的申请
        }
        return post;
    }
};
```

### 1143. Longest Common Subsequence | 最长公共子序列
🥈给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
```
输入：text1 = "abcde", text2 = "ace" 输出：3 解释：最长公共子序列是 "ace"，它的长度为 3。
输入：text1 = "abc", text2 = "def" 输出：0
```
---

标签: `DP` `二维数组`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(M*N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //dp[i][j]表示在字符串text1[0...r-1]中和字符串text2[0...c-1]中最长公共子序列的长度为dp[i][j]。
        vector<vector<int>> dp(r + 1, vector<int> (c + 1));
        for (int i = 1; i != r + 1; ++i) {
            for (int j = 1; j != c + 1; ++j) { 
                if (text1[i - 1] == text2[j - 1]) {
                    //🪁dp[i][j]位置对应两字符串的最后一个字符相同时，dp[i][j]取决于dp[i-1][j-1]加一
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    //🪁否则应取dp[i-1][j]，dp[i][j-1]中的较大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        } 
        return dp[r][c];
    }
};
```

标签: `DP` `一维数组`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int r = text1.size(), c = text2.size();
        //🪁用一维数组可以来存储状态可以节省空间
        vector<int> dp(c + 1);
        for (int i = 0; i != r; ++i) {
            vector<int> temp(c + 1);
            for (int j = 1; j != c + 1; ++j) {
                temp[j] = (text1[i] == text2[j - 1]) ? dp[j - 1] + 1 : max(temp[j - 1], dp[j]);
            }
            dp = temp;
        }
        return dp[c];
    }
};
```
