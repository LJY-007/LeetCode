## Table of Contents
|序号|题目|难度|
|-|-|-|
|63|[Unique Paths II \| 不同路径 II](#63-Unique-Paths-II--不同路径-II)|Medium|
|509|[Fibonacci Number \| 斐波那契数](#509-Fibonacci-Number--斐波那契数)|Medium|

### Nots
动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）
```
KEYS：
最优子结构：opt[n] = best of(opt[n-1], opt[n-2]...)
存储中间状态：opt[n]
递推公式（DP方程，状态转移方程）: 
例如 Fib(opt[i] = opt[n-1]+opt[n-2]); 二维路径(opt[i,j]=opt[i+1][j]+opt[i][j+1])(且判断a[i][j]是否为空)
```

### 63. Unique Paths II | 不同路径 II
🥈一个机器人位于一个 m x n 网格的左上角，试图达到网格的右下角且每次只能向下或者向右移动一步。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。
```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
] 
输出: 2
解释: 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右
```
---

标签: `DP`<br>
时间复杂度:`O(M*N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid[0][0] == 1) return 0;
        obstacleGrid[0][0] = 1; //起点的可达路径应设置为1

        int r = obstacleGrid.size(), c = obstacleGrid[0].size();
        //🪁每个点位的可达路径由上方和左方的点位对应的可达路径得出
        for (int i = 0; i != r; ++i) {
            //第一列每一点位（每一行的第一个点位）的路径值由其上方的点位决定
            if (i) {
                obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
            }
            for (int j = 1; j != c; ++j) {
                //第一行的每一个点位的路径值由其左方的点位决定
                if (i == 0) {
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1];
                } else {
                    //🪁递推方程为opt[i][j]=opt[i][j-1]+opt[i-1][j]，如果opt[i][j]=1，则需要归零
                    obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j];
                }
            }
        }
        return obstacleGrid[r - 1][c - 1];
    }
};
```



### 509. Fibonacci Number | 斐波那契数
🥈斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。给定 N，计算 F(N)。
```
输入：4 输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
```
---

标签: `递归法`<br>
时间复杂度:`O(2^N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        return (N <= 1) ? N : fib(N - 1) + fib(N - 2);
    }
};
```

标签: `递归法` `记忆化搜索`<br>
时间复杂度:`O(N)` 空间复杂度:`O(N)`
```c++
class Solution {
public:
    int fib(int N) {
        vector<int> memo(N + 1); //初始化vector为N+1个0
        return fibStored(N, memo);
    }

    //🪁记忆化搜索利用数组来存储已经计算过的值避免重复调用计算
    int fibStored(int N, vector<int> &memo) {
        if (N <= 1) return N;
        //当fib(N)尚未计算时，执行递归计算
        if (memo[N] == 0) {
            memo[N] = fibStored(N - 1, memo) + fibStored(N - 2, memo);
        }
        return memo[N];
    }
};
```

标签: `DP自底向上`<br>
时间复杂度:`O(N)` 空间复杂度:`O(1)`
```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int pre = 0, post = 1;
        for (int i = 2; i <= N; ++i) {
            post += pre;
            pre = post - pre; //结合减法避免了临时变量的申请
        }
        return post;
    }
};
```
