## Table of Contents
|åºå·|é¢˜ç›®|éš¾åº¦|
|:--:|:-|:-:|
|1|[Two Sum \| ä¸¤æ•°ä¹‹å’Œ](#1-Two-Sum--ä¸¤æ•°ä¹‹å’Œ)|Easy|
|3|||
|14|[Longest Common Prefix \| æœ€é•¿å…¬å…±å‰ç¼€](#14-Longest-Common-Prefix--æœ€é•¿å…¬å…±å‰ç¼€)|Easy|
|30|||
|76|||
|208|[Implement Trie (Prefix Tree) \| å®ç° Trie (å‰ç¼€æ ‘)](#208-Implement-Trie-Prefix-Tree--å®ç°-Trie-å‰ç¼€æ ‘)|Medium|
|290|||
|380|[Insert Delete GetRandom O(1) \| å¸¸æ•°æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ ](#380-Insert-Delete-Getrandom-o1--å¸¸æ•°æ—¶é—´æ’å…¥åˆ é™¤å’Œè·å–éšæœºå…ƒç´ )|Medium|
|459|||
|468|||

### 1. Two Sum | ä¸¤æ•°ä¹‹å’Œ
ğŸ¥‰ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚
```
ç»™å®š nums = [2, 7, 11, 15], target = 9 è¿”å› [0, 1]
```
---

æ ‡ç­¾: `å“ˆå¸Œè¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i != nums.size(); ++i) {
            //ğŸªå…ˆæ£€æŸ¥åæ’å…¥ï¼Œå¯ä»¥å¾ˆå¥½çš„å¤„ç†é‡å¤æ•°å­—å’Œä¸ºtargetçš„æƒ…å†µ
            if (map.find(target - nums[i]) != map.end()) {
                return {map[target - nums[i]], i};
            } else {
                map[nums[i]] = i;
            }
        }
        return {};
    }
};
```

### 14. Longest Common Prefix | æœ€é•¿å…¬å…±å‰ç¼€
ğŸ¥‰ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾å­—ç¬¦ä¸²æ•°ç»„ä¸­çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚
å¦‚æœä¸å­˜åœ¨å…¬å…±å‰ç¼€ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² ""ã€‚
```
è¾“å…¥: ["flower","flow","flight"] è¾“å‡º: "fl"
è¾“å…¥: ["dog","racecar","car"] è¾“å‡º: ""
```
---

æ ‡ç­¾: `å­—ç¬¦ä¸²`<br>
æ—¶é—´å¤æ‚åº¦:`O(MN)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return "";
        for (int j = 0; ; ++j) {
            //ğŸªåŒæŒ‡é’ˆ(ä¸‹æ ‡)åˆ†åˆ«éå†æ•°ç»„å’Œå­—ç¬¦ä¸²,å½“å‡ºç°ä¸åŒå­—æ¯æˆ–è€…ä¸‹æ ‡è¶Šç•Œæ—¶è¿”å›
            if (j == strs[0].size()) return strs[0].substr(0, j);
            int curr = strs[0][j];
            for (int i = 1; i != strs.size(); ++i) {
                if (j == strs[i].size() || strs[i][j] != curr) return strs[0].substr(0, j);
            }
        }
    }
};
```

### 380. Insert Delete GetRandom O(1) | å¸¸æ•°æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ 
ğŸ¥ˆè®¾è®¡ä¸€ä¸ªæ”¯æŒåœ¨å¹³å‡æ—¶é—´å¤æ‚åº¦ O(1)Â ä¸‹ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œçš„æ•°æ®ç»“æ„ã€‚
```
insert(val)ï¼šå½“å…ƒç´  val ä¸å­˜åœ¨æ—¶ï¼Œå‘é›†åˆä¸­æ’å…¥è¯¥é¡¹ã€‚
remove(val)ï¼šå…ƒç´  val å­˜åœ¨æ—¶ï¼Œä»é›†åˆä¸­ç§»é™¤è¯¥é¡¹ã€‚
getRandomï¼šéšæœºè¿”å›ç°æœ‰é›†åˆä¸­çš„ä¸€é¡¹ã€‚æ¯ä¸ªå…ƒç´ åº”è¯¥æœ‰ç›¸åŒçš„æ¦‚ç‡è¢«è¿”å›ã€‚
```
---

æ ‡ç­¾: `å“ˆå¸Œè¡¨` `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class RandomizedSet {
public:
    /** Initialize your data structure here. */
    RandomizedSet() {}
    
    //ğŸªO(1)æ—¶é—´æŸ¥æ‰¾å¯ä½¿ç”¨map,åŒæ—¶ç»“åˆæ•°ç»„çš„éšæœºä¸‹æ ‡æ¥å®ç°å…ƒç´ çš„éšæœºè¿”å›
    bool insert(int val) {
        if (map.find(val) != map.end()) return false;
        nums.push_back(val);
        map[val] = nums.size() - 1;
        return true;
    }
    
    //ğŸªä½¿ç”¨æ•°ç»„æœ€æœ«å°¾çš„å…ƒç´ æ¥å¡«è¡¥å¾…åˆ é™¤çš„å…ƒç´ ä½ç½®,ç¡®ä¿éšæœºé€‰å–çš„æ­£å¸¸æ‰§è¡Œ
    bool remove(int val) {
        if (map.find(val) == map.end()) return false;
        nums[map[val]] = nums.back();
        map[nums.back()] = map[val];
        nums.pop_back();
        map.erase(val);
        return true;
    }
    
    int getRandom() {
        return nums[rand() % nums.size()];
    }
private:
    unordered_map<int, int> map;
    vector<int> nums;
};
```

### 208. Implement Trie (Prefix Tree) | å®ç° Trie (å‰ç¼€æ ‘)
ğŸ¥ˆå®ç°ä¸€ä¸ª Trie (å‰ç¼€æ ‘)ï¼ŒåŒ…å« insert, search, å’Œ startsWith è¿™ä¸‰ä¸ªæ“ä½œã€‚
```
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // è¿”å› true
trie.search("app");     // è¿”å› false
trie.startsWith("app"); // è¿”å› true
trie.insert("app");   
trie.search("app");     // è¿”å› true
```
---

æ ‡ç­¾: `å‰ç¼€æ ‘` `å­—ç¬¦ä¸²` `å“ˆå¸Œè¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(M)` ç©ºé—´å¤æ‚åº¦:`O(M)`
```c++
struct TrieNode {
    //ğŸªæ¯ä¸ªç»“ç‚¹ä¸­å«æœ‰ä¸‰ä¸ªä¿¡æ¯:è®°å½•ä»¥æ­¤å­—æ¯ä¸ºç»“å°¾çš„æ€»æ•°;è®°å½•å‰ç¼€æ‰€åœ¨çš„å•è¯æ€»æ•°;è®°å½•åç»­ç»“ç‚¹æŒ‡é’ˆ
    int end;
    int path;
    unordered_map<char, TrieNode*> nexts;
    TrieNode() : end(0), path(0) {}
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode *curr = root;
        for (char c : word) {
            if (!curr->nexts.count(c)) curr->nexts[c] = new TrieNode();
            curr = curr->nexts[c];
            curr->path++;
        }
        curr->end++; 
    }
    
    bool search(string word) {
        TrieNode *curr = root;
        for (char c : word) {
            if (!curr->nexts.count(c)) return false;
            curr = curr->nexts[c];
        }
        return curr->end;
    }
    
    bool startsWith(string prefix) {
        TrieNode *curr = root;
        for (char c : prefix) {
            if (!curr->nexts.count(c)) return false;
            curr = curr->nexts[c];
        }
        return true;
    }

private:
    TrieNode *root;
};
```
