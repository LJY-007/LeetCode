## Table of Contents
|åºå·|é¢˜ç›®|éš¾åº¦|
|:--:|:-|:-:|
|1|[Two Sum \| ä¸¤æ•°ä¹‹å’Œ](#1-Two-Sum--ä¸¤æ•°ä¹‹å’Œ)|Easy|
|6|[ZigZag Conversion \| Z å­—å½¢å˜æ¢](#6-ZigZag-Conversion--Z-å­—å½¢å˜æ¢)|Medium|
|48|[Rotate Image \| æ—‹è½¬å›¾åƒ](#48-Rotate-Image--æ—‹è½¬å›¾åƒ)|Medium|
|54|[Spiral Matrix \| èºæ—‹çŸ©é˜µ](#54-Spiral-Matrix--èºæ—‹çŸ©é˜µ)|Medium|
|74|[Search a 2D Matrix \| æœç´¢äºŒç»´çŸ©é˜µ](#74-Search-a-2D-Matrix--æœç´¢äºŒç»´çŸ©é˜µ)|Medium|
|75|[Sort Colors \| é¢œè‰²åˆ†ç±»](#75-Sort-Colors--é¢œè‰²åˆ†ç±»)|Medium|
|164|[Maximum Gap \| æœ€å¤§é—´è·](#164-Maximum-Gap--æœ€å¤§é—´è·)|Hard|
|240|[Search a 2D Matrix II \| æœç´¢äºŒç»´çŸ©é˜µ II](#240-Search-a-2D-Matrix-II--æœç´¢äºŒç»´çŸ©é˜µ-II)|Medium|
|295|[Find Median from Data Stream \| æ•°æ®æµä¸­çš„ä¸­ä½æ•°](#295-Find-Median-from-Data-Stream--æ•°æ®æµä¸­çš„ä¸­ä½æ•°)|Hard|
|380|[Insert Delete GetRandom O(1) \| å¸¸æ•°æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ ](#380-Insert-Delete-Getrandom-o1--å¸¸æ•°æ—¶é—´æ’å…¥åˆ é™¤å’Œè·å–éšæœºå…ƒç´ )|Medium|
|912|[Sort an Array \| æ’åºæ•°ç»„](#912-Sort-an-Array--æ’åºæ•°ç»„)|Medium|

### 1. Two Sum | ä¸¤æ•°ä¹‹å’Œ
ğŸ¥‰ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚
```
ç»™å®š nums = [2, 7, 11, 15], target = 9 è¿”å› [0, 1]
```
---

æ ‡ç­¾: `å“ˆå¸Œè¡¨`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i != nums.size(); ++i) {
            //ğŸªå…ˆæ£€æŸ¥åæ’å…¥ï¼Œå¯ä»¥å¾ˆå¥½çš„å¤„ç†é‡å¤æ•°å­—å’Œä¸ºtargetçš„æƒ…å†µ
            if (map.find(target - nums[i]) != map.end()) {
                return {map[target - nums[i]], i};
            } else {
                map[nums[i]] = i;
            }
        }
        return {};
    }
};
```

### 6. ZigZag Conversion | Z å­—å½¢å˜æ¢
ğŸ¥ˆå°†ä¸€ä¸ªç»™å®šå­—ç¬¦ä¸²æ ¹æ®ç»™å®šçš„è¡Œæ•°ï¼Œä»¥ä»ä¸Šå¾€ä¸‹ã€ä»å·¦åˆ°å³è¿›è¡Œ Z å­—å½¢æ’åˆ—ã€‚
```
è¾“å…¥: s = "LEETCODEISHIRING", numRows =Â 4 è¾“å‡º:Â "LDREOEIIECIHNTSG"
è§£é‡Š:
L     D     R
E   O E   I I
E C   I H   N
T     S     G
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    string convert(string s, int numRows) {
        vector<string> strs(numRows);
        if (numRows == 1) return s;
        
        //ğŸªæŒ‰ç…§å­—æ¯çš„éå†é¡ºåºå‹å…¥å¯¹åº”çš„è¡Œ(å­—ç¬¦ä¸²)
        int row  = 0;
        bool go_down = false;
        for (char c : s) {
            strs[row] += c;
            if (row == 0 || row == numRows - 1) go_down = !go_down;
            go_down ? row++ : row--;
        }
        
        string res;
        for (string str : strs) res += str;
        return res;
    }
};
```

### 48. Rotate Image | æ—‹è½¬å›¾åƒ
ğŸ¥ˆç»™å®šä¸€ä¸ª n Ã— n çš„äºŒç»´çŸ©é˜µè¡¨ç¤ºä¸€ä¸ªå›¾åƒã€‚å°†å›¾åƒé¡ºæ—¶é’ˆæ—‹è½¬ 90 åº¦ã€‚
è¯´æ˜ï¼šä½ å¿…é¡»åœ¨åŸåœ°æ—‹è½¬å›¾åƒï¼Œè¿™æ„å‘³ç€ä½ éœ€è¦ç›´æ¥ä¿®æ”¹è¾“å…¥çš„äºŒç»´çŸ©é˜µã€‚è¯·ä¸è¦ä½¿ç”¨å¦ä¸€ä¸ªçŸ©é˜µæ¥æ—‹è½¬å›¾åƒã€‚
```
ç»™å®š matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

åŸåœ°æ—‹è½¬è¾“å…¥çŸ©é˜µï¼Œä½¿å…¶å˜ä¸º:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int s1 = 0, s2 = matrix.size() - 1;
        
        while (s1 <= s2) {
            for (int i = 0; i != s2 - s1; ++i) {
                //ğŸªçŸ©é˜µé¡ºæ—¶é’ˆæ—‹è½¬æ—¶,æ›¿æ¢æ“ä½œéœ€è¦æŒ‰ç…§é€†æ—¶é’ˆä¾æ¬¡è¿›è¡Œ
                int temp = matrix[s1][s1 + i];
                matrix[s1][s1 + i] = matrix[s2 - i][s1];
                matrix[s2 - i][s1] = matrix[s2][s2 - i];
                matrix[s2][s2 - i] = matrix[s1 + i][s2];
                matrix[s1 + i][s2] = temp;
            }
            s1++; s2--;
        }
    }
};
```

### 54. Spiral Matrix | èºæ—‹çŸ©é˜µ
ğŸ¥ˆç»™å®šä¸€ä¸ªåŒ…å« m x n ä¸ªå…ƒç´ çš„çŸ©é˜µï¼ˆm è¡Œ, n åˆ—ï¼‰ï¼Œè¯·æŒ‰ç…§é¡ºæ—¶é’ˆèºæ—‹é¡ºåºï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
```
è¾“å…¥:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
è¾“å‡º: [1,2,3,6,9,8,7,4,5]
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if (matrix.empty()) return res;
        int x1 = 0, y1 = 0;
        int x2 = matrix.size() - 1, y2 = matrix[0].size() - 1;

        while (x1 <= x2 && y1 <= y2) {
            int x = x1, y = y1;
            //ğŸªæ¯æ¬¡åªéå†æœ€å¤–è¾¹çš„ä¸€åœˆ,å•ç‹¬å¤„ç†åªæœ‰ä¸€è¡Œæˆ–ä¸€åˆ—çš„æƒ…å†µ
            if (x1 == x2) {
                while (y <= y2) res.push_back(matrix[x1][y++]);
            } else if (y1 == y2) {
                while (x <= x2) res.push_back(matrix[x++][y1]);
            } else {
                while (y != y2) res.push_back(matrix[x1][y++]);
                while (x != x2) res.push_back(matrix[x++][y2]);
                while (y != y1) res.push_back(matrix[x2][y--]);
                while (x != x1) res.push_back(matrix[x--][y1]);
            }
            x1++; y1++; x2--; y2--;
        }
        return res;
    }
};
```

### 74. Search a 2D Matrix | æœç´¢äºŒç»´çŸ©é˜µ
ğŸ¥ˆç¼–å†™ä¸€ä¸ªé«˜æ•ˆçš„ç®—æ³•æ¥åˆ¤æ–­ m x n çŸ©é˜µä¸­ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ä¸ªç›®æ ‡å€¼ã€‚è¯¥çŸ©é˜µå…·æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼š<br>
æ¯è¡Œä¸­çš„æ•´æ•°ä»å·¦åˆ°å³æŒ‰å‡åºæ’åˆ—ã€‚æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°å¤§äºå‰ä¸€è¡Œçš„æœ€åä¸€ä¸ªæ•´æ•°ã€‚
```
è¾“å…¥:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
è¾“å‡º: true
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N+M)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        //ğŸªéå†çŸ©é˜µçš„æœ€å³ç«¯,æ‰¾åˆ°æ‰€å±çš„è¡Œ,åœ¨è¡Œå†…ç»§ç»­éå†
        int row = matrix.size();
        for (int i = 0; i != matrix.size(); ++i) {
            if (matrix[0].empty()) return false;
            if (target <= matrix[i][matrix[0].size() - 1]) {
                row = i;
                break;
            }
        }
        if (row == matrix.size()) return false;
        for (int j = 0; j != matrix[0].size(); ++j) {
            if (target == matrix[row][j]) return true;
        }
        return false;
    }
};
```

### 75. Sort Colors | é¢œè‰²åˆ†ç±»
ğŸ¥ˆç»™å®šä¸€ä¸ªåŒ…å«çº¢è‰²ã€ç™½è‰²å’Œè“è‰²ï¼Œä¸€å…± n ä¸ªå…ƒç´ çš„æ•°ç»„ï¼ŒåŸåœ°å¯¹å®ƒä»¬è¿›è¡Œæ’åºï¼Œä½¿å¾—ç›¸åŒé¢œè‰²çš„å…ƒç´ ç›¸é‚»ï¼Œå¹¶æŒ‰ç…§çº¢è‰²ã€ç™½è‰²ã€è“è‰²é¡ºåºæ’åˆ—ã€‚
æ­¤é¢˜ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•´æ•° 0ã€Â 1 å’Œ 2 åˆ†åˆ«è¡¨ç¤ºçº¢è‰²ã€ç™½è‰²å’Œè“è‰²ã€‚
```
è¾“å…¥: [2,0,2,1,1,0] è¾“å‡º: [0,0,1,1,2,2]
```
---

æ ‡ç­¾: `æ’åº`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int curr = 0, less = 0, more = nums.size() - 1;
        //ğŸªå°çš„æ•°å¾€å‰æ’,å¤§çš„æ•°å¾€åæ’
        while (curr <= more) {
            switch (nums[curr]) {
                case 0: swap(nums[curr++], nums[less++]); break;
                case 1: curr++; break;
                case 2: swap(nums[curr], nums[more--]); break;
            }
        }
    }
};
```

### 164. Maximum Gap | æœ€å¤§é—´è·
ğŸ…ï¸ç»™å®šä¸€ä¸ªæ— åºçš„æ•°ç»„ï¼Œæ‰¾å‡ºæ•°ç»„åœ¨æ’åºä¹‹åï¼Œç›¸é‚»å…ƒç´ ä¹‹é—´æœ€å¤§çš„å·®å€¼ã€‚
å¦‚æœæ•°ç»„å…ƒç´ ä¸ªæ•°å°äº 2ï¼Œåˆ™è¿”å› 0ã€‚
```
è¾“å…¥: [3,6,9,1] è¾“å‡º: 3
è§£é‡Š: æ’åºåçš„æ•°ç»„æ˜¯ [1,3,6,9], å…¶ä¸­ç›¸é‚»å…ƒç´  (3,6) å’Œ (6,9) ä¹‹é—´éƒ½å­˜åœ¨æœ€å¤§å·®å€¼ 3ã€‚
```
---

æ ‡ç­¾: `æ’åº`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        if (nums.size() < 2) return 0;
        int Max = nums[0], Min = nums[0];
        for (int i : nums) {
            Max = max(Max, i);
            Min = min(Min, i);
        }
        if (Max == Min) return 0;

        //ğŸªå°†Nä¸ªæ•°æ®æ”¾å…¥N+1ä¸ªæ¡¶(æœ€å¤§é—´è·ä¸åœ¨æ¡¶å†…äº§ç”Ÿ),æ¯ä¸ªæ¡¶å†…å­˜å‚¨ä¸‰ä¸ªä¿¡æ¯(æ˜¯å¦å­˜åœ¨æ•°æ®,æ¡¶å†…æœ€å¤§å€¼,æ¡¶å†…æœ€å°å€¼)
        vector<bool> appear(nums.size() + 1);
        vector<int> Maxs(nums.size() + 1, Min);
        vector<int> Mins(nums.size() + 1, Max);
        for (int i : nums ) {
            int bucket = int ((i - Min) * nums.size() / float(Max - Min)); //å®šä½æ•°æ®åº”æ”¾å…¥ç¬¬å‡ ä¸ªæ¡¶
            appear[bucket] = true;
            Maxs[bucket] = max(Maxs[bucket], i);
            Mins[bucket] = min(Mins[bucket], i);
        }

        //ğŸªæ¯”è¾ƒæ¯ä¸€ä¸ªéç©ºæ¡¶çš„æœ€å°å€¼ä¸å‰ä¸€ä¸ªéç©ºæ¡¶çš„æœ€å¤§å€¼ä¹‹å·®,å–æœ€å¤§å€¼å³ä¸ºæœ€å¤§é—´è·
        int res = 0;
        int pre_max = Maxs[0];
        for (int i = 1; i != appear.size(); ++i) {
            if (appear[i]) {
                res = max(res, Mins[i] - pre_max);
                pre_max = Maxs[i];
            }
        }
        
        return res;
    }
};
```

### 240. Search a 2D Matrix II | æœç´¢äºŒç»´çŸ©é˜µ II
ğŸ¥ˆç¼–å†™ä¸€ä¸ªé«˜æ•ˆçš„ç®—æ³•æ¥æœç´¢Â mÂ xÂ nÂ çŸ©é˜µ matrix ä¸­çš„ä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯¥çŸ©é˜µå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š<br>
æ¯è¡Œçš„å…ƒç´ ä»å·¦åˆ°å³å‡åºæ’åˆ—ã€‚
æ¯åˆ—çš„å…ƒç´ ä»ä¸Šåˆ°ä¸‹å‡åºæ’åˆ—ã€‚
```
ç°æœ‰çŸ©é˜µmatrixå¦‚ä¸‹:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
ç»™å®š target = 5ï¼Œè¿”å› trueã€‚
ç»™å®š target = 20ï¼Œè¿”å› falseã€‚
```
---

æ ‡ç­¾: `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N+M)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
        int i = 0, j = matrix[0].size() - 1;
        //ğŸªä»çŸ©é˜µçš„å³ä¸Šè§’å¼€å§‹å¯»æ‰¾,targetç­‰äºå½“å‰å€¼æ—¶è¿”å›true,å¦åˆ™ç»§ç»­(å°äºæ—¶å¾€å·¦,å¤§äºæ—¶å¾€ä¸‹)
        while (i < matrix.size() && j >= 0) {
            if (target == matrix[i][j]) return true;
            target > matrix[i][j] ? i++ : j--;
        }
        return false;
    }
};
```

### 295. Find Median from Data Stream | æ•°æ®æµä¸­çš„ä¸­ä½æ•°
ğŸ…ï¸å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚<br>
è®¾è®¡ä¸€ä¸ªæ”¯æŒä»¥ä¸‹ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼š
```
void addNum(int num) - ä»æ•°æ®æµä¸­æ·»åŠ ä¸€ä¸ªæ•´æ•°åˆ°æ•°æ®ç»“æ„ä¸­ã€‚
double findMedian() - è¿”å›ç›®å‰æ‰€æœ‰å…ƒç´ çš„ä¸­ä½æ•°ã€‚
```

æ ‡ç­¾: `å †` `åŠ¨æ€æ’åº`<br>
æ—¶é—´å¤æ‚åº¦:`O(logN)` ç©ºé—´å¤æ‚åº¦:`O(N)`
```c++
class MedianFinder {
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (less.empty()) {
            less.push(num);
            return;
        }
        //ğŸªå°†æ–°æ•°æ®å‹å…¥å †ä¸­(ä¸å¤§æ ¹å †çš„æ ¹å…ƒç´ æ¯”è¾ƒ),åŒæ—¶ç¡®ä¿å¤§æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ç­‰äºæˆ–å¤§äºå°æ ¹å †ä¸Šå…ƒç´ ä¸ªæ•°ä¸€ä¸ª
        num <= less.top() ?  less.push(num) : great.push(num);
        if (less.size() > great.size() + 1) {
            great.push(less.top());
            less.pop();
        } else if (less.size() < great.size()) {
            less.push(great.top());
            great.pop();
        }
    }
    
    double findMedian() {
        return less.size() == great.size() ? (less.top() + great.top()) / 2.0 : less.top();
    }
    
private:
    //ğŸªåˆ©ç”¨ä¸€ä¸ªå¤§æ ¹å †(å­˜è¾ƒå°çš„æ•°)å’Œä¸€ä¸ªå°æ ¹å †(å­˜è¾ƒå¤§çš„æ•°)æ¥å­˜å‚¨æ•°æ®
    priority_queue<int, vector<int>, less<int>> less;
    priority_queue<int, vector<int>, greater<int>> great;
};
```

### 380. Insert Delete GetRandom O(1) | å¸¸æ•°æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ 
ğŸ¥ˆè®¾è®¡ä¸€ä¸ªæ”¯æŒåœ¨å¹³å‡æ—¶é—´å¤æ‚åº¦ O(1)Â ä¸‹ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œçš„æ•°æ®ç»“æ„ã€‚
```
insert(val)ï¼šå½“å…ƒç´  val ä¸å­˜åœ¨æ—¶ï¼Œå‘é›†åˆä¸­æ’å…¥è¯¥é¡¹ã€‚
remove(val)ï¼šå…ƒç´  val å­˜åœ¨æ—¶ï¼Œä»é›†åˆä¸­ç§»é™¤è¯¥é¡¹ã€‚
getRandomï¼šéšæœºè¿”å›ç°æœ‰é›†åˆä¸­çš„ä¸€é¡¹ã€‚æ¯ä¸ªå…ƒç´ åº”è¯¥æœ‰ç›¸åŒçš„æ¦‚ç‡è¢«è¿”å›ã€‚
```
---

æ ‡ç­¾: `å“ˆå¸Œè¡¨` `æ•°ç»„`<br>
æ—¶é—´å¤æ‚åº¦:`O(N)` ç©ºé—´å¤æ‚åº¦:`O(1)`
```c++
class RandomizedSet {
public:
    /** Initialize your data structure here. */
    RandomizedSet() {}
    
    //ğŸªO(1)æ—¶é—´æŸ¥æ‰¾å¯ä½¿ç”¨map,åŒæ—¶ç»“åˆæ•°ç»„çš„éšæœºä¸‹æ ‡æ¥å®ç°å…ƒç´ çš„éšæœºè¿”å›
    bool insert(int val) {
        if (map.find(val) != map.end()) return false;
        nums.push_back(val);
        map[val] = nums.size() - 1;
        return true;
    }
    
    //ğŸªä½¿ç”¨æ•°ç»„æœ€æœ«å°¾çš„å…ƒç´ æ¥å¡«è¡¥å¾…åˆ é™¤çš„å…ƒç´ ä½ç½®,ç¡®ä¿éšæœºé€‰å–çš„æ­£å¸¸æ‰§è¡Œ
    bool remove(int val) {
        if (map.find(val) == map.end()) return false;
        nums[map[val]] = nums.back();
        map[nums.back()] = map[val];
        nums.pop_back();
        map.erase(val);
        return true;
    }
    
    int getRandom() {
        return nums[rand() % nums.size()];
    }
private:
    unordered_map<int, int> map;
    vector<int> nums;
};
```

### 912. Sort an Array | æ’åºæ•°ç»„
ğŸ¥ˆç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚
```
è¾“å…¥ï¼šnums = [5,2,3,1] è¾“å‡ºï¼š[1,2,3,5]
è¾“å…¥ï¼šnums = [5,1,1,2,0,0] è¾“å‡ºï¼š[0,0,1,1,2,5]
```
---

#### Kinds of Sorts
|æ’åºæ–¹æ³•|å¹³å‡æ—¶é—´å¤æ‚åº¦|æœ€åæ—¶é—´å¤æ‚åº¦|æœ€å¥½æ—¶é—´å¤æ‚åº¦|ç©ºé—´å¤æ‚åº¦|ç¨³å®šæ€§|
|:-|:-:|:-:|:-:|:-:|:-:|
|[Insertion Sort \| æ’å…¥æ’åº](#Insertion-Sort--æ’å…¥æ’åº)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Hill Sort \| å¸Œå°”æ’åº](#Hill-Sort--å¸Œå°”æ’åº)|O(N^1.3)|O(N^2)|O(N)|O(1)|No|
|[Selection Sort \| é€‰æ‹©æ’åº](#Selection-Sort--é€‰æ‹©æ’åº)|O(N^2)|O(N^2)|O(N^2)|O(1)|No|
|[Heap Sort \| å †æ’åºâ­ï¸](#Heap-Sort--å †æ’åº)|O(NlogN)|O(NlogN)|O(NlogN)|O(1)|No|
|[Bubble Sort \| å†’æ³¡æ’åº](#Bubble-Sort--å†’æ³¡æ’åº)|O(N^2)|O(N^2)|O(N)|O(1)|Yes|
|[Quick Sort \| å¿«é€Ÿæ’åºâ­ï¸](#Quick-Sort--å¿«é€Ÿæ’åº)|O(NlogN)|O(N^2)|O(NlogN)|O(logN)|No|
|[Merge Sort \| å½’å¹¶æ’åºâ­ï¸](#Merge-Sort--å½’å¹¶æ’åº)|O(NlogN)|O(NlogN)|O(NlogN)|O(N)|Yes|
|è®¡æ•°æ’åº|O(N+k)|O(N+k)|O(N+k)|O(N+K)|Yes|
|æ¡¶æ’åº|O(N+k)|O(N^2)|O(N)|O(N+k)|Yes|
|åŸºæ•°æ’åº|O(N*k)|O(N*k)|O(N*k)|O(N+k)|Yes|

#### Insertion Sort | æ’å…¥æ’åº
æ—¶é—´å¤æ‚åº¦: `O(N^2)`  ç©ºé—´å¤æ‚åº¦: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 1; i != nums.size(); ++i) {
            //ğŸªå¯¹æ–°æ’å…¥çš„æ•°æ®ä»åå‘å‰éå†æ¯”è¾ƒä¾¿äºä½ç½®äº¤æ¢
            for (int j = i - 1; j >= 0 && nums[j + 1] < nums[j]; --j) {
                //ğŸªä½¿ç”¨å†…å±‚jä¸‹æ ‡è¿›è¡Œç›¸é‚»å…ƒç´ çš„æ¯”è¾ƒå¯ä»¥é¿å…å¯¹içš„è¯¯æ”¹
                swap(nums[j + 1], nums[j]);
            }
        }
        return nums;
    }
};
```

#### Hill Sort | å¸Œå°”æ’åº

#### Selection Sort | é€‰æ‹©æ’åº
æ—¶é—´å¤æ‚åº¦: `O(N^2)`  ç©ºé—´å¤æ‚åº¦: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for (int i = 0; i != nums.size() - 1; ++i) {
            //ğŸªå¾ªç¯è¿‡ç¨‹ä¸­æ¯é‡åˆ°å°äºèµ·å§‹ä½ç½®çš„å…ƒç´ å°±äº¤æ¢ä¸€æ¬¡,ç¡®å®šæœ€å°å€¼æ”¾åœ¨æœ€å‰
            for (int j = i + 1; j != nums.size(); ++j) {
                if (nums[i] > nums[j]) swap(nums[i], nums[j]);
            }
        }
        return nums;
    }
};
```

#### Heap Sort | å †æ’åº
```c++
class Solution {
public:
    vector<int> heapSort(vector<int> &nums) {
        priority_queue<int, vector<int>, greater<int>> temp;
        vector<int> result;
        for (int num : nums) temp.push(num);
        while (!temp.empty()) {
            result.push_back(temp.top());
            temp.pop();
        }
        return result;
    }
}
```

##### Bubble Sort | å†’æ³¡æ’åº
æ—¶é—´å¤æ‚åº¦: `O(N^2)`  ç©ºé—´å¤æ‚åº¦: `O(1)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int times = nums.size() - 1; //æ€»å…±è¿›è¡ŒN-1æ¬¡å¾ªç¯
        while (times--) {
            for (int i = 0; i != nums.size() - 1; ++i) {
                //ğŸªå¾ªç¯è¿‡ç¨‹ä¸­æ¯é‡åˆ°ç›¸é‚»é€†åºå¯¹å°±äº¤æ¢ä¸€æ¬¡,ç¡®å®šæœ€å¤§å€¼æ”¾åœ¨æœ€å
                if (nums[i] > nums[i + 1]) swap(nums[i], nums[i + 1]);
            }
        } //ğŸªæ€»çš„äº¤æ¢æ¬¡æ•°ä¸æ•°ç»„çš„é€†åºæ•°ç›¸ç­‰
        return nums;
    }
};
```

#### Quick Sort | å¿«é€Ÿæ’åº
æ—¶é—´å¤æ‚åº¦: `O(NlogN)`  ç©ºé—´å¤æ‚åº¦: `O(logN)`
```c++
class Solution {
public:
    void quickSort(vector<int> &nums, int begin, int end) {
        if (end <= begin) return;
        int pivot = partition(nums, begin, end);
        quickSort(nums, begin, pivot - 1); //ğŸªpivotå¯èƒ½ç­‰äºbeginæˆ–end,é€€å‡ºæ—¶endä¼šå°äºbegin
        quickSort(nums, pivot + 1, end);
    }

    int partition(vector<int> &nums, int begin, int end) {
        //ğŸªpivotï¼šæ ‡æ†ä½ç½®ï¼›lessï¼šæ‰€æœ‰å°äºpivotå…ƒç´ çš„ä¸‹ä¸€ä½ç½®
        int pivot = end, less = begin;
        srand(time(NULL)); //è®¾ç½®ä¸€ä¸ªéšæœºç§å­
        int p_rand = int(rand() % 100 / 100.0 * (end - begin + 1)) + begin; //ç”Ÿæˆéšæœºä½ç½®
        swap(nums[pivot], nums[p_rand]);
        for (int i = begin; i != end; ++i) {
            if (nums[i] < nums[pivot]) swap(nums[i], nums[less++]);
        }
        swap(nums[less], nums[end]);
        return less; 
    }
};
```

#### Merge Sort | å½’å¹¶æ’åº
æ—¶é—´å¤æ‚åº¦: `O(NlogN)`  ç©ºé—´å¤æ‚åº¦: `O(N)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }
    
    void mergeSort(vector<int> &nums, int left, int right) {
        if (left >= right) return; //ç»ˆæ­¢æ¡ä»¶
        int mid = (left + right) >> 1;
        //ğŸªåˆ†æ²»(é€’å½’),åˆå¹¶å­åºåˆ—
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        mergeSubsequence(nums, left, mid, right);
    }
    
    void mergeSubsequence(vector<int> &nums, int left, int mid, int right) {
        vector<int> temp;
        int i = left, j = mid + 1;
        while (i <= mid && j <= right) {
            nums[i] < nums[j] ? temp.push_back(nums[i++]) : temp.push_back(nums[j++]);
        }
        while (i <= mid) temp.push_back(nums[i++]);
        while (j <= right) temp.push_back(nums[j++]);
        for (int i = 0; i != temp.size(); ++i) nums[left + i] = temp[i];
    }
};
```

#### è®¡æ•°æ’åº

#### æ¡¶æ’åº
æ—¶é—´å¤æ‚åº¦: `O(N+K)`  ç©ºé—´å¤æ‚åº¦: `O(K)`
```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int max_val = nums[0], min_val = nums[0];
        for (int i = 1; i != nums.size(); ++i) {
            max_val = max(max_val, nums[i]);
            min_val = min(min_val, nums[i]);
        }
        //ğŸªç»“åˆæ•°ç»„çš„ä¸‹æ ‡å¡«å…¥å¯¹åº”æ•°å­—å‡ºç°çš„æ¬¡æ•°
        vector<int> occur(max_val - min_val + 1);
        for (int i = 0; i != nums.size(); ++i) {
            occur[nums[i] - min_val]++;
        }
        //éå†è¾“å‡ºå¯¹åº”æ¬¡æ•°çš„å…ƒç´ 
        int i = 0;
        for (int j = 0; j != max_val - min_val + 1; ++j) {
            while (occur[j]--) nums[i++] = j + min_val; 
        }
        return nums;
    }
};
```
#### åŸºæ•°æ’åº
